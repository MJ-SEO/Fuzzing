        -:    0:Source:../lib/CJSON/cJSON.c
        -:    0:Graph:cJSON.gcno
        -:    0:Data:cJSON.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*
        -:    2:  Copyright (c) 2009-2017 Dave Gamble and cJSON contributors
        -:    3:
        -:    4:  Permission is hereby granted, free of charge, to any person obtaining a copy
        -:    5:  of this software and associated documentation files (the "Software"), to deal
        -:    6:  in the Software without restriction, including without limitation the rights
        -:    7:  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        -:    8:  copies of the Software, and to permit persons to whom the Software is
        -:    9:  furnished to do so, subject to the following conditions:
        -:   10:
        -:   11:  The above copyright notice and this permission notice shall be included in
        -:   12:  all copies or substantial portions of the Software.
        -:   13:
        -:   14:  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        -:   15:  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        -:   16:  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        -:   17:  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        -:   18:  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        -:   19:  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
        -:   20:  THE SOFTWARE.
        -:   21:*/
        -:   22:
        -:   23:/* cJSON */
        -:   24:/* JSON parser in C. */
        -:   25:
        -:   26:/* disable warnings about old C89 functions in MSVC */
        -:   27:#if !defined(_CRT_SECURE_NO_DEPRECATE) && defined(_MSC_VER)
        -:   28:#define _CRT_SECURE_NO_DEPRECATE
        -:   29:#endif
        -:   30:
        -:   31:#ifdef __GNUC__
        -:   32:#pragma GCC visibility push(default)
        -:   33:#endif
        -:   34:#if defined(_MSC_VER)
        -:   35:#pragma warning (push)
        -:   36:/* disable warning about single line comments in system headers */
        -:   37:#pragma warning (disable : 4001)
        -:   38:#endif
        -:   39:
        -:   40:#include <string.h>
        -:   41:#include <stdio.h>
        -:   42:#include <math.h>
        -:   43:#include <stdlib.h>
        -:   44:#include <limits.h>
        -:   45:#include <ctype.h>
        -:   46:#include <float.h>
        -:   47:
        -:   48:#ifdef ENABLE_LOCALES
        -:   49:#include <locale.h>
        -:   50:#endif
        -:   51:
        -:   52:#if defined(_MSC_VER)
        -:   53:#pragma warning (pop)
        -:   54:#endif
        -:   55:#ifdef __GNUC__
        -:   56:#pragma GCC visibility pop
        -:   57:#endif
        -:   58:
        -:   59:#include "cJSON.h"
        -:   60:
        -:   61:/* define our own boolean type */
        -:   62:#ifdef true
        -:   63:#undef true
        -:   64:#endif
        -:   65:#define true ((cJSON_bool)1)
        -:   66:
        -:   67:#ifdef false
        -:   68:#undef false
        -:   69:#endif
        -:   70:#define false ((cJSON_bool)0)
        -:   71:
        -:   72:/* define isnan and isinf for ANSI C, if in C99 or above, isnan and isinf has been defined in math.h */
        -:   73:#ifndef isinf
        -:   74:#define isinf(d) (isnan((d - d)) && !isnan(d))
        -:   75:#endif
        -:   76:#ifndef isnan
        -:   77:#define isnan(d) (d != d)
        -:   78:#endif
        -:   79:
        -:   80:#ifndef NAN
        -:   81:#ifdef _WIN32
        -:   82:#define NAN sqrt(-1.0)
        -:   83:#else
        -:   84:#define NAN 0.0/0.0
        -:   85:#endif
        -:   86:#endif
        -:   87:
        -:   88:typedef struct {
        -:   89:    const unsigned char *json;
        -:   90:    size_t position;
        -:   91:} error;
        -:   92:static error global_error = { NULL, 0 };
        -:   93:
function cJSON_GetErrorPtr called 0 returned 0% blocks executed 0%
    #####:   94:CJSON_PUBLIC(const char *) cJSON_GetErrorPtr(void)
        -:   95:{
    #####:   96:    return (const char*) (global_error.json + global_error.position);
        -:   97:}
        -:   98:
function cJSON_GetStringValue called 0 returned 0% blocks executed 0%
    #####:   99:CJSON_PUBLIC(char *) cJSON_GetStringValue(const cJSON * const item) 
        -:  100:{
    #####:  101:    if (!cJSON_IsString(item)) 
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  102:    {
    #####:  103:		printf("real zz\n");    
call    0 never executed
    #####:  104:	    return NULL;
        -:  105:    }
        -:  106:
    #####:  107:    return item->valuestring;
        -:  108:}
        -:  109:
function cJSON_GetNumberValue called 0 returned 0% blocks executed 0%
    #####:  110:CJSON_PUBLIC(double) cJSON_GetNumberValue(const cJSON * const item) 
        -:  111:{
    #####:  112:    if (!cJSON_IsNumber(item)) 
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  113:    {
    #####:  114:    	printf("zz\n");
call    0 never executed
    #####:  115:	    return (double) NAN;
        -:  116:    }
        -:  117:
    #####:  118:    return item->valuedouble;
        -:  119:}
        -:  120:
        -:  121:/* This is a safeguard to prevent copy-pasters from using incompatible C and header files */
        -:  122:#if (CJSON_VERSION_MAJOR != 1) || (CJSON_VERSION_MINOR != 7) || (CJSON_VERSION_PATCH != 15)
        -:  123:    #error cJSON.h and cJSON.c have different versions. Make sure that both have the same.
        -:  124:#endif
        -:  125:
function cJSON_Version called 0 returned 0% blocks executed 0%
    #####:  126:CJSON_PUBLIC(const char*) cJSON_Version(void)
        -:  127:{
        -:  128:    static char version[15];
    #####:  129:    sprintf(version, "%i.%i.%i", CJSON_VERSION_MAJOR, CJSON_VERSION_MINOR, CJSON_VERSION_PATCH);
        -:  130:
    #####:  131:    return version;
        -:  132:}
        -:  133:
        -:  134:/* Case insensitive string comparison, doesn't consider two NULL pointers equal though */
function case_insensitive_strcmp called 0 returned 0% blocks executed 0%
    #####:  135:static int case_insensitive_strcmp(const unsigned char *string1, const unsigned char *string2)
        -:  136:{
    #####:  137:    if ((string1 == NULL) || (string2 == NULL))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  138:    {
    #####:  139:        return 1;
        -:  140:    }
        -:  141:
    #####:  142:    if (string1 == string2)
branch  0 never executed
branch  1 never executed
        -:  143:    {
    #####:  144:        return 0;
        -:  145:    }
        -:  146:
    #####:  147:    for(; tolower(*string1) == tolower(*string2); (void)string1++, string2++)
branch  0 never executed
branch  1 never executed
        -:  148:    {
    #####:  149:        if (*string1 == '\0')
branch  0 never executed
branch  1 never executed
        -:  150:        {
    #####:  151:            return 0;
        -:  152:        }
        -:  153:    }
        -:  154:
    #####:  155:    return tolower(*string1) - tolower(*string2);
        -:  156:}
        -:  157:
        -:  158:typedef struct internal_hooks
        -:  159:{
        -:  160:    void *(CJSON_CDECL *allocate)(size_t size);
        -:  161:    void (CJSON_CDECL *deallocate)(void *pointer);
        -:  162:    void *(CJSON_CDECL *reallocate)(void *pointer, size_t size);
        -:  163:} internal_hooks;
        -:  164:
        -:  165:#if defined(_MSC_VER)
        -:  166:/* work around MSVC error C2322: '...' address of dllimport '...' is not static */
        -:  167:static void * CJSON_CDECL internal_malloc(size_t size)
        -:  168:{
        -:  169:    return malloc(size);
        -:  170:}
        -:  171:static void CJSON_CDECL internal_free(void *pointer)
        -:  172:{
        -:  173:    free(pointer);
        -:  174:}
        -:  175:static void * CJSON_CDECL internal_realloc(void *pointer, size_t size)
        -:  176:{
        -:  177:    return realloc(pointer, size);
        -:  178:}
        -:  179:#else
        -:  180:#define internal_malloc malloc
        -:  181:#define internal_free free
        -:  182:#define internal_realloc realloc
        -:  183:#endif
        -:  184:
        -:  185:/* strlen of character literals resolved at compile time */
        -:  186:#define static_strlen(string_literal) (sizeof(string_literal) - sizeof(""))
        -:  187:
        -:  188:static internal_hooks global_hooks = { internal_malloc, internal_free, internal_realloc };
        -:  189:
function cJSON_strdup called 0 returned 0% blocks executed 0%
    #####:  190:static unsigned char* cJSON_strdup(const unsigned char* string, const internal_hooks * const hooks)
        -:  191:{
    #####:  192:    size_t length = 0;
    #####:  193:    unsigned char *copy = NULL;
        -:  194:
    #####:  195:    if (string == NULL)
branch  0 never executed
branch  1 never executed
        -:  196:    {
    #####:  197:        return NULL;
        -:  198:    }
        -:  199:
    #####:  200:    length = strlen((const char*)string) + sizeof("");
    #####:  201:    copy = (unsigned char*)hooks->allocate(length);
call    0 never executed
    #####:  202:    if (copy == NULL)
branch  0 never executed
branch  1 never executed
        -:  203:    {
    #####:  204:        return NULL;
        -:  205:    }
    #####:  206:    memcpy(copy, string, length);
        -:  207:
    #####:  208:    return copy;
        -:  209:}
        -:  210:
function cJSON_InitHooks called 0 returned 0% blocks executed 0%
    #####:  211:CJSON_PUBLIC(void) cJSON_InitHooks(cJSON_Hooks* hooks)
        -:  212:{
    #####:  213:    if (hooks == NULL)
branch  0 never executed
branch  1 never executed
        -:  214:    {
        -:  215:        /* Reset hooks */
    #####:  216:        global_hooks.allocate = malloc;
    #####:  217:        global_hooks.deallocate = free;
    #####:  218:        global_hooks.reallocate = realloc;
    #####:  219:        return;
        -:  220:    }
        -:  221:
    #####:  222:    global_hooks.allocate = malloc;
    #####:  223:    if (hooks->malloc_fn != NULL)
branch  0 never executed
branch  1 never executed
        -:  224:    {
    #####:  225:        global_hooks.allocate = hooks->malloc_fn;
        -:  226:    }
        -:  227:
    #####:  228:    global_hooks.deallocate = free;
    #####:  229:    if (hooks->free_fn != NULL)
branch  0 never executed
branch  1 never executed
        -:  230:    {
    #####:  231:        global_hooks.deallocate = hooks->free_fn;
        -:  232:    }
        -:  233:
        -:  234:    /* use realloc only if both free and malloc are used */
    #####:  235:    global_hooks.reallocate = NULL;
    #####:  236:    if ((global_hooks.allocate == malloc) && (global_hooks.deallocate == free))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  237:    {
    #####:  238:        global_hooks.reallocate = realloc;
        -:  239:    }
        -:  240:}
        -:  241:
        -:  242:/* Internal constructor. */
function cJSON_New_Item called 154 returned 100% blocks executed 100%
      154:  243:static cJSON *cJSON_New_Item(const internal_hooks * const hooks)
        -:  244:{
      154:  245:    cJSON* node = (cJSON*)hooks->allocate(sizeof(cJSON));
call    0 returned 154
      154:  246:    if (node)
branch  0 taken 154 (fallthrough)
branch  1 taken 0
        -:  247:    {
      154:  248:        memset(node, '\0', sizeof(cJSON));
        -:  249:    }
        -:  250:
      154:  251:    return node;
        -:  252:}
        -:  253:
        -:  254:/* Delete a cJSON structure. */
function cJSON_Delete called 42 returned 100% blocks executed 100%
       42:  255:CJSON_PUBLIC(void) cJSON_Delete(cJSON *item)
        -:  256:{
       42:  257:    cJSON *next = NULL;
      238:  258:    while (item != NULL)
branch  0 taken 154
branch  1 taken 42 (fallthrough)
        -:  259:    {
      154:  260:        next = item->next;
      154:  261:        if (!(item->type & cJSON_IsReference) && (item->child != NULL))
branch  0 taken 154 (fallthrough)
branch  1 taken 0
branch  2 taken 14 (fallthrough)
branch  3 taken 140
        -:  262:        {
       14:  263:            cJSON_Delete(item->child);
call    0 returned 14
        -:  264:        }
      154:  265:        if (!(item->type & cJSON_IsReference) && (item->valuestring != NULL))
branch  0 taken 154 (fallthrough)
branch  1 taken 0
branch  2 taken 63 (fallthrough)
branch  3 taken 91
        -:  266:        {
       63:  267:            global_hooks.deallocate(item->valuestring);
call    0 returned 63
        -:  268:        }
      154:  269:        if (!(item->type & cJSON_StringIsConst) && (item->string != NULL))
branch  0 taken 154 (fallthrough)
branch  1 taken 0
branch  2 taken 147 (fallthrough)
branch  3 taken 7
        -:  270:        {
      147:  271:            global_hooks.deallocate(item->string);
call    0 returned 147
        -:  272:        }
      154:  273:        global_hooks.deallocate(item);
call    0 returned 154
      154:  274:        item = next;
        -:  275:    }
       42:  276:}
        -:  277:
        -:  278:/* get the decimal point character of the current locale */
function get_decimal_point called 49 returned 100% blocks executed 100%
       49:  279:static unsigned char get_decimal_point(void)
        -:  280:{
        -:  281:#ifdef ENABLE_LOCALES
        -:  282:    struct lconv *lconv = localeconv();
        -:  283:    return (unsigned char) lconv->decimal_point[0];
        -:  284:#else
       49:  285:    return '.';
        -:  286:#endif
        -:  287:}
        -:  288:
        -:  289:typedef struct
        -:  290:{
        -:  291:    const unsigned char *content;
        -:  292:    size_t length;
        -:  293:    size_t offset;
        -:  294:    size_t depth; /* How deeply nested (in arrays/objects) is the input at the current offset. */
        -:  295:    internal_hooks hooks;
        -:  296:} parse_buffer;
        -:  297:
        -:  298:/* check if the given size is left to read in a given parse buffer (starting with 1) */
        -:  299:#define can_read(buffer, size) ((buffer != NULL) && (((buffer)->offset + size) <= (buffer)->length))
        -:  300:/* check if the buffer can be accessed at the given index (starting with 0) */
        -:  301:#define can_access_at_index(buffer, index) ((buffer != NULL) && (((buffer)->offset + index) < (buffer)->length))
        -:  302:#define cannot_access_at_index(buffer, index) (!can_access_at_index(buffer, index))
        -:  303:/* get a pointer to the buffer at the position */
        -:  304:#define buffer_at_offset(buffer) ((buffer)->content + (buffer)->offset)
        -:  305:
        -:  306:/* Parse the input text to generate a number, and populate the result into item. */
function parse_number called 49 returned 100% blocks executed 70%
       49:  307:static cJSON_bool parse_number(cJSON * const item, parse_buffer * const input_buffer)
        -:  308:{
       49:  309:    double number = 0;
       49:  310:    unsigned char *after_end = NULL;
        -:  311:    unsigned char number_c_string[64];
       49:  312:    unsigned char decimal_point = get_decimal_point();
call    0 returned 49
       49:  313:    size_t i = 0;
        -:  314:
       49:  315:    if ((input_buffer == NULL) || (input_buffer->content == NULL))
branch  0 taken 49 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 49
        -:  316:    {
    #####:  317:        return false;
        -:  318:    }
        -:  319:
        -:  320:    /* copy the number into a temporary buffer and replace '.' with the decimal point
        -:  321:     * of the current locale (for strtod)
        -:  322:     * This also takes care of '\0' not necessarily being available for marking the end of the input */
      567:  323:    for (i = 0; (i < (sizeof(number_c_string) - 1)) && can_access_at_index(input_buffer, i); i++)
branch  0 taken 0 (fallthrough)
branch  1 taken 189
branch  2 taken 0 (fallthrough)
branch  3 taken 189
branch  4 taken 189
branch  5 taken 0 (fallthrough)
        -:  324:    {
      189:  325:        switch (buffer_at_offset(input_buffer)[i])
branch  0 taken 140
branch  1 taken 0
branch  2 taken 49
        -:  326:        {
      140:  327:            case '0':
        -:  328:            case '1':
        -:  329:            case '2':
        -:  330:            case '3':
        -:  331:            case '4':
        -:  332:            case '5':
        -:  333:            case '6':
        -:  334:            case '7':
        -:  335:            case '8':
        -:  336:            case '9':
        -:  337:            case '+':
        -:  338:            case '-':
        -:  339:            case 'e':
        -:  340:            case 'E':
      140:  341:                number_c_string[i] = buffer_at_offset(input_buffer)[i];
      140:  342:                break;
        -:  343:
    #####:  344:            case '.':
    #####:  345:                number_c_string[i] = decimal_point;
    #####:  346:                break;
        -:  347:
       49:  348:            default:
       49:  349:                goto loop_end;
        -:  350:        }
        -:  351:    }
    #####:  352:loop_end:
       49:  353:    number_c_string[i] = '\0';
        -:  354:
       49:  355:    number = strtod((const char*)number_c_string, (char**)&after_end);
call    0 returned 49
       49:  356:    if (number_c_string == after_end)
branch  0 taken 0 (fallthrough)
branch  1 taken 49
        -:  357:    {
    #####:  358:        return false; /* parse_error */
        -:  359:    }
        -:  360:
       49:  361:    item->valuedouble = number;
        -:  362:
        -:  363:    /* use saturation in case of overflow */
       49:  364:    if (number >= INT_MAX)
branch  0 taken 0 (fallthrough)
branch  1 taken 49
        -:  365:    {
    #####:  366:        item->valueint = INT_MAX;
        -:  367:    }
       49:  368:    else if (number <= (double)INT_MIN)
branch  0 taken 0 (fallthrough)
branch  1 taken 49
        -:  369:    {
    #####:  370:        item->valueint = INT_MIN;
        -:  371:    }
        -:  372:    else
        -:  373:    {
       49:  374:        item->valueint = (int)number;
        -:  375:    }
        -:  376:
       49:  377:    item->type = cJSON_Number;
        -:  378:
       49:  379:    input_buffer->offset += (size_t)(after_end - number_c_string);
       49:  380:    return true;
        -:  381:}
        -:  382:
        -:  383:/* don't ask me, but the original cJSON_SetNumberValue returns an integer or double */
function cJSON_SetNumberHelper called 0 returned 0% blocks executed 0%
    #####:  384:CJSON_PUBLIC(double) cJSON_SetNumberHelper(cJSON *object, double number)
        -:  385:{
    #####:  386:    if (number >= INT_MAX)
branch  0 never executed
branch  1 never executed
        -:  387:    {
    #####:  388:        object->valueint = INT_MAX;
        -:  389:    }
    #####:  390:    else if (number <= (double)INT_MIN)
branch  0 never executed
branch  1 never executed
        -:  391:    {
    #####:  392:        object->valueint = INT_MIN;
        -:  393:    }
        -:  394:    else
        -:  395:    {
    #####:  396:        object->valueint = (int)number;
        -:  397:    }
        -:  398:
    #####:  399:    return object->valuedouble = number;
        -:  400:}
        -:  401:
function cJSON_SetValuestring called 0 returned 0% blocks executed 0%
    #####:  402:CJSON_PUBLIC(char*) cJSON_SetValuestring(cJSON *object, const char *valuestring)
        -:  403:{
    #####:  404:    char *copy = NULL;
        -:  405:    /* if object's type is not cJSON_String or is cJSON_IsReference, it should not set valuestring */
    #####:  406:    if (!(object->type & cJSON_String) || (object->type & cJSON_IsReference))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  407:    {
    #####:  408:        return NULL;
        -:  409:    }
    #####:  410:    if (strlen(valuestring) <= strlen(object->valuestring))
branch  0 never executed
branch  1 never executed
        -:  411:    {
    #####:  412:        strcpy(object->valuestring, valuestring);
    #####:  413:        return object->valuestring;
        -:  414:    }
    #####:  415:    copy = (char*) cJSON_strdup((const unsigned char*)valuestring, &global_hooks);
call    0 never executed
    #####:  416:    if (copy == NULL)
branch  0 never executed
branch  1 never executed
        -:  417:    {
    #####:  418:        return NULL;
        -:  419:    }
    #####:  420:    if (object->valuestring != NULL)
branch  0 never executed
branch  1 never executed
        -:  421:    {
    #####:  422:        cJSON_free(object->valuestring);
call    0 never executed
        -:  423:    }
    #####:  424:    object->valuestring = copy;
        -:  425:
    #####:  426:    return copy;
        -:  427:}
        -:  428:
        -:  429:typedef struct
        -:  430:{
        -:  431:    unsigned char *buffer;
        -:  432:    size_t length;
        -:  433:    size_t offset;
        -:  434:    size_t depth; /* current nesting depth (for formatted printing) */
        -:  435:    cJSON_bool noalloc;
        -:  436:    cJSON_bool format; /* is this print a formatted print */
        -:  437:    internal_hooks hooks;
        -:  438:} printbuffer;
        -:  439:
        -:  440:/* realloc printbuffer if necessary to have at least "needed" bytes more */
function ensure called 0 returned 0% blocks executed 0%
    #####:  441:static unsigned char* ensure(printbuffer * const p, size_t needed)
        -:  442:{
    #####:  443:    unsigned char *newbuffer = NULL;
    #####:  444:    size_t newsize = 0;
        -:  445:
    #####:  446:    if ((p == NULL) || (p->buffer == NULL))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  447:    {
    #####:  448:        return NULL;
        -:  449:    }
        -:  450:
    #####:  451:    if ((p->length > 0) && (p->offset >= p->length))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  452:    {
        -:  453:        /* make sure that offset is valid */
    #####:  454:        return NULL;
        -:  455:    }
        -:  456:
    #####:  457:    if (needed > INT_MAX)
branch  0 never executed
branch  1 never executed
        -:  458:    {
        -:  459:        /* sizes bigger than INT_MAX are currently not supported */
    #####:  460:        return NULL;
        -:  461:    }
        -:  462:
    #####:  463:    needed += p->offset + 1;
    #####:  464:    if (needed <= p->length)
branch  0 never executed
branch  1 never executed
        -:  465:    {
    #####:  466:        return p->buffer + p->offset;
        -:  467:    }
        -:  468:
    #####:  469:    if (p->noalloc) {
branch  0 never executed
branch  1 never executed
    #####:  470:        return NULL;
        -:  471:    }
        -:  472:
        -:  473:    /* calculate new buffer size */
    #####:  474:    if (needed > (INT_MAX / 2))
branch  0 never executed
branch  1 never executed
        -:  475:    {
        -:  476:        /* overflow of int, use INT_MAX if possible */
    #####:  477:        if (needed <= INT_MAX)
branch  0 never executed
branch  1 never executed
        -:  478:        {
    #####:  479:            newsize = INT_MAX;
        -:  480:        }
        -:  481:        else
        -:  482:        {
    #####:  483:            return NULL;
        -:  484:        }
        -:  485:    }
        -:  486:    else
        -:  487:    {
    #####:  488:        newsize = needed * 2;
        -:  489:    }
        -:  490:
    #####:  491:    if (p->hooks.reallocate != NULL)
branch  0 never executed
branch  1 never executed
        -:  492:    {
        -:  493:        /* reallocate with realloc if available */
    #####:  494:        newbuffer = (unsigned char*)p->hooks.reallocate(p->buffer, newsize);
call    0 never executed
    #####:  495:        if (newbuffer == NULL)
branch  0 never executed
branch  1 never executed
        -:  496:        {
    #####:  497:            p->hooks.deallocate(p->buffer);
call    0 never executed
    #####:  498:            p->length = 0;
    #####:  499:            p->buffer = NULL;
        -:  500:
    #####:  501:            return NULL;
        -:  502:        }
        -:  503:    }
        -:  504:    else
        -:  505:    {
        -:  506:        /* otherwise reallocate manually */
    #####:  507:        newbuffer = (unsigned char*)p->hooks.allocate(newsize);
call    0 never executed
    #####:  508:        if (!newbuffer)
branch  0 never executed
branch  1 never executed
        -:  509:        {
    #####:  510:            p->hooks.deallocate(p->buffer);
call    0 never executed
    #####:  511:            p->length = 0;
    #####:  512:            p->buffer = NULL;
        -:  513:
    #####:  514:            return NULL;
        -:  515:        }
        -:  516:        
    #####:  517:        memcpy(newbuffer, p->buffer, p->offset + 1);
    #####:  518:        p->hooks.deallocate(p->buffer);
call    0 never executed
        -:  519:    }
    #####:  520:    p->length = newsize;
    #####:  521:    p->buffer = newbuffer;
        -:  522:
    #####:  523:    return newbuffer + p->offset;
        -:  524:}
        -:  525:
        -:  526:/* calculate the new length of the string in a printbuffer and update the offset */
function update_offset called 0 returned 0% blocks executed 0%
    #####:  527:static void update_offset(printbuffer * const buffer)
        -:  528:{
    #####:  529:    const unsigned char *buffer_pointer = NULL;
    #####:  530:    if ((buffer == NULL) || (buffer->buffer == NULL))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  531:    {
    #####:  532:        return;
        -:  533:    }
    #####:  534:    buffer_pointer = buffer->buffer + buffer->offset;
        -:  535:
    #####:  536:    buffer->offset += strlen((const char*)buffer_pointer);
        -:  537:}
        -:  538:
        -:  539:/* securely comparison of floating-point variables */
function compare_double called 0 returned 0% blocks executed 0%
    #####:  540:static cJSON_bool compare_double(double a, double b)
        -:  541:{
    #####:  542:    double maxVal = fabs(a) > fabs(b) ? fabs(a) : fabs(b);
branch  0 never executed
branch  1 never executed
    #####:  543:    return (fabs(a - b) <= maxVal * DBL_EPSILON);
        -:  544:}
        -:  545:
        -:  546:/* Render the number nicely from the given item into a string. */
function print_number called 0 returned 0% blocks executed 0%
    #####:  547:static cJSON_bool print_number(const cJSON * const item, printbuffer * const output_buffer)
        -:  548:{
    #####:  549:    unsigned char *output_pointer = NULL;
    #####:  550:    double d = item->valuedouble;
    #####:  551:    int length = 0;
    #####:  552:    size_t i = 0;
    #####:  553:    unsigned char number_buffer[26] = {0}; /* temporary buffer to print the number into */
    #####:  554:    unsigned char decimal_point = get_decimal_point();
call    0 never executed
    #####:  555:    double test = 0.0;
        -:  556:
    #####:  557:    if (output_buffer == NULL)
branch  0 never executed
branch  1 never executed
        -:  558:    {
    #####:  559:        return false;
        -:  560:    }
        -:  561:
        -:  562:    /* This checks for NaN and Infinity */
    #####:  563:    if (isnan(d) || isinf(d))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  564:    {
    #####:  565:        length = sprintf((char*)number_buffer, "null");
        -:  566:    }
        -:  567:    else
        -:  568:    {
        -:  569:        /* Try 15 decimal places of precision to avoid nonsignificant nonzero digits */
    #####:  570:        length = sprintf((char*)number_buffer, "%1.15g", d);
        -:  571:
        -:  572:        /* Check whether the original double can be recovered */
    #####:  573:        if ((sscanf((char*)number_buffer, "%lg", &test) != 1) || !compare_double((double)test, d));
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:  574:        {
        -:  575:            /* If not, print with 17 decimal places of precision */
    #####:  576:            length = sprintf((char*)number_buffer, "%1.17g", d);
        -:  577:        }
        -:  578:    }
        -:  579:
        -:  580:    /* sprintf failed or buffer overrun occurred */
    #####:  581:    if ((length < 0) || (length > (int)(sizeof(number_buffer) - 1)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  582:    {
    #####:  583:        return false;
        -:  584:    }
        -:  585:
        -:  586:    /* reserve appropriate space in the output */
    #####:  587:    output_pointer = ensure(output_buffer, (size_t)length + sizeof(""));
call    0 never executed
    #####:  588:    if (output_pointer == NULL)
branch  0 never executed
branch  1 never executed
        -:  589:    {
    #####:  590:        return false;
        -:  591:    }
        -:  592:
        -:  593:    /* copy the printed number to the output and replace locale
        -:  594:     * dependent decimal point with '.' */
    #####:  595:    for (i = 0; i < ((size_t)length); i++)
branch  0 never executed
branch  1 never executed
        -:  596:    {
    #####:  597:        if (number_buffer[i] == decimal_point)
branch  0 never executed
branch  1 never executed
        -:  598:        {
    #####:  599:            output_pointer[i] = '.';
    #####:  600:            continue;
        -:  601:        }
        -:  602:
    #####:  603:        output_pointer[i] = number_buffer[i];
        -:  604:    }
    #####:  605:    output_pointer[i] = '\0';
        -:  606:
    #####:  607:    output_buffer->offset += (size_t)length;
        -:  608:
    #####:  609:    return true;
        -:  610:}
        -:  611:
        -:  612:/* parse 4 digit hexadecimal number */
function parse_hex4 called 0 returned 0% blocks executed 0%
    #####:  613:static unsigned parse_hex4(const unsigned char * const input)
        -:  614:{
    #####:  615:    unsigned int h = 0;
    #####:  616:    size_t i = 0;
        -:  617:
    #####:  618:    for (i = 0; i < 4; i++)
branch  0 never executed
branch  1 never executed
        -:  619:    {
        -:  620:        /* parse digit */
    #####:  621:        if ((input[i] >= '0') && (input[i] <= '9'))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  622:        {
    #####:  623:            h += (unsigned int) input[i] - '0';
        -:  624:        }
    #####:  625:        else if ((input[i] >= 'A') && (input[i] <= 'F'))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  626:        {
    #####:  627:            h += (unsigned int) 10 + input[i] - 'A';
        -:  628:        }
    #####:  629:        else if ((input[i] >= 'a') && (input[i] <= 'f'))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  630:        {
    #####:  631:            h += (unsigned int) 10 + input[i] - 'a';
        -:  632:        }
        -:  633:        else /* invalid */
        -:  634:        {
    #####:  635:            return 0;
        -:  636:        }
        -:  637:
    #####:  638:        if (i < 3)
branch  0 never executed
branch  1 never executed
        -:  639:        {
        -:  640:            /* shift left to make place for the next nibble */
    #####:  641:            h = h << 4;
        -:  642:        }
        -:  643:    }
        -:  644:
    #####:  645:    return h;
        -:  646:}
        -:  647:
        -:  648:/* converts a UTF-16 literal to UTF-8
        -:  649: * A literal can be one or two sequences of the form \uXXXX */
function utf16_literal_to_utf8 called 0 returned 0% blocks executed 0%
    #####:  650:static unsigned char utf16_literal_to_utf8(const unsigned char * const input_pointer, const unsigned char * const input_end, unsigned char **output_pointer)
        -:  651:{
    #####:  652:    long unsigned int codepoint = 0;
    #####:  653:    unsigned int first_code = 0;
    #####:  654:    const unsigned char *first_sequence = input_pointer;
    #####:  655:    unsigned char utf8_length = 0;
    #####:  656:    unsigned char utf8_position = 0;
    #####:  657:    unsigned char sequence_length = 0;
    #####:  658:    unsigned char first_byte_mark = 0;
        -:  659:
    #####:  660:    if ((input_end - first_sequence) < 6)
branch  0 never executed
branch  1 never executed
        -:  661:    {
        -:  662:        /* input ends unexpectedly */
    #####:  663:        goto fail;
        -:  664:    }
        -:  665:
        -:  666:    /* get the first utf16 sequence */
    #####:  667:    first_code = parse_hex4(first_sequence + 2);
call    0 never executed
        -:  668:
        -:  669:    /* check that the code is valid */
    #####:  670:    if (((first_code >= 0xDC00) && (first_code <= 0xDFFF)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  671:    {
    #####:  672:        goto fail;
        -:  673:    }
        -:  674:
        -:  675:    /* UTF16 surrogate pair */
    #####:  676:    if ((first_code >= 0xD800) && (first_code <= 0xDBFF))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  677:    {
    #####:  678:        const unsigned char *second_sequence = first_sequence + 6;
    #####:  679:        unsigned int second_code = 0;
    #####:  680:        sequence_length = 12; /* \uXXXX\uXXXX */
        -:  681:
    #####:  682:        if ((input_end - second_sequence) < 6)
branch  0 never executed
branch  1 never executed
        -:  683:        {
        -:  684:            /* input ends unexpectedly */
    #####:  685:            goto fail;
        -:  686:        }
        -:  687:
    #####:  688:        if ((second_sequence[0] != '\\') || (second_sequence[1] != 'u'))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  689:        {
        -:  690:            /* missing second half of the surrogate pair */
        -:  691:            goto fail;
        -:  692:        }
        -:  693:
        -:  694:        /* get the second utf16 sequence */
    #####:  695:        second_code = parse_hex4(second_sequence + 2);
call    0 never executed
        -:  696:        /* check that the code is valid */
    #####:  697:        if ((second_code < 0xDC00) || (second_code > 0xDFFF))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:  698:        {
        -:  699:            /* invalid second half of the surrogate pair */
        -:  700:            goto fail;
        -:  701:        }
        -:  702:
        -:  703:
        -:  704:        /* calculate the unicode codepoint from the surrogate pair */
    #####:  705:        codepoint = 0x10000 + (((first_code & 0x3FF) << 10) | (second_code & 0x3FF));
        -:  706:    }
        -:  707:    else
        -:  708:    {
    #####:  709:        sequence_length = 6; /* \uXXXX */
    #####:  710:        codepoint = first_code;
        -:  711:    }
        -:  712:
        -:  713:    /* encode as UTF-8
        -:  714:     * takes at maximum 4 bytes to encode:
        -:  715:     * 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx */
    #####:  716:    if (codepoint < 0x80)
branch  0 never executed
branch  1 never executed
        -:  717:    {
        -:  718:        /* normal ascii, encoding 0xxxxxxx */
    #####:  719:        utf8_length = 1;
        -:  720:    }
    #####:  721:    else if (codepoint < 0x800)
branch  0 never executed
branch  1 never executed
        -:  722:    {
        -:  723:        /* two bytes, encoding 110xxxxx 10xxxxxx */
    #####:  724:        utf8_length = 2;
    #####:  725:        first_byte_mark = 0xC0; /* 11000000 */
        -:  726:    }
    #####:  727:    else if (codepoint < 0x10000)
branch  0 never executed
branch  1 never executed
        -:  728:    {
        -:  729:        /* three bytes, encoding 1110xxxx 10xxxxxx 10xxxxxx */
    #####:  730:        utf8_length = 3;
    #####:  731:        first_byte_mark = 0xE0; /* 11100000 */
        -:  732:    }
    #####:  733:    else if (codepoint <= 0x10FFFF)
branch  0 never executed
branch  1 never executed
        -:  734:    {
        -:  735:        /* four bytes, encoding 1110xxxx 10xxxxxx 10xxxxxx 10xxxxxx */
    #####:  736:        utf8_length = 4;
    #####:  737:        first_byte_mark = 0xF0; /* 11110000 */
        -:  738:    }
        -:  739:    else
        -:  740:    {
        -:  741:        /* invalid unicode codepoint */
    #####:  742:        goto fail;
        -:  743:    }
        -:  744:
        -:  745:    /* encode as utf8 */
    #####:  746:    for (utf8_position = (unsigned char)(utf8_length - 1); utf8_position > 0; utf8_position--)
branch  0 never executed
branch  1 never executed
        -:  747:    {
        -:  748:        /* 10xxxxxx */
    #####:  749:        (*output_pointer)[utf8_position] = (unsigned char)((codepoint | 0x80) & 0xBF);
    #####:  750:        codepoint >>= 6;
        -:  751:    }
        -:  752:    /* encode first byte */
    #####:  753:    if (utf8_length > 1)
branch  0 never executed
branch  1 never executed
        -:  754:    {
    #####:  755:        (*output_pointer)[0] = (unsigned char)((codepoint | first_byte_mark) & 0xFF);
        -:  756:    }
        -:  757:    else
        -:  758:    {
    #####:  759:        (*output_pointer)[0] = (unsigned char)(codepoint & 0x7F);
        -:  760:    }
        -:  761:
    #####:  762:    *output_pointer += utf8_length;
        -:  763:
    #####:  764:    return sequence_length;
        -:  765:
    #####:  766:fail:
    #####:  767:    return 0;
        -:  768:}
        -:  769:
        -:  770:/* Parse the input text into an unescaped cinput, and populate item. */
function parse_string called 210 returned 100% blocks executed 39%
      210:  771:static cJSON_bool parse_string(cJSON * const item, parse_buffer * const input_buffer)
        -:  772:{
      210:  773:    const unsigned char *input_pointer = buffer_at_offset(input_buffer) + 1;
      210:  774:    const unsigned char *input_end = buffer_at_offset(input_buffer) + 1;
      210:  775:    unsigned char *output_pointer = NULL;
      210:  776:    unsigned char *output = NULL;
        -:  777:
        -:  778:    /* not a string */
      210:  779:    if (buffer_at_offset(input_buffer)[0] != '\"')
branch  0 taken 0 (fallthrough)
branch  1 taken 210
        -:  780:    {
    #####:  781:        goto fail;
        -:  782:    }
        -:  783:
        -:  784:    {
        -:  785:        /* calculate approximate size of the output (overestimate) */
      210:  786:        size_t allocation_length = 0;
      210:  787:        size_t skipped_bytes = 0;
     1820:  788:        while (((size_t)(input_end - input_buffer->content) < input_buffer->length) && (*input_end != '\"'))
branch  0 taken 1610 (fallthrough)
branch  1 taken 0
branch  2 taken 1400
branch  3 taken 210 (fallthrough)
        -:  789:        {
        -:  790:            /* is escape sequence */
     1400:  791:            if (input_end[0] == '\\')
branch  0 taken 0 (fallthrough)
branch  1 taken 1400
        -:  792:            {
    #####:  793:                if ((size_t)(input_end + 1 - input_buffer->content) >= input_buffer->length)
branch  0 never executed
branch  1 never executed
        -:  794:                {
        -:  795:                    /* prevent buffer overflow when last input character is a backslash */
    #####:  796:                    goto fail;
        -:  797:                }
    #####:  798:                skipped_bytes++;
    #####:  799:                input_end++;
        -:  800:            }
     1400:  801:            input_end++;
        -:  802:        }
      210:  803:        if (((size_t)(input_end - input_buffer->content) >= input_buffer->length) || (*input_end != '\"'))
branch  0 taken 210 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 210
        -:  804:        {
        -:  805:            goto fail; /* string ended unexpectedly */
        -:  806:        }
        -:  807:
        -:  808:        /* This is at most how much we need for the output */
      210:  809:        allocation_length = (size_t) (input_end - buffer_at_offset(input_buffer)) - skipped_bytes;
      210:  810:        output = (unsigned char*)input_buffer->hooks.allocate(allocation_length + sizeof(""));
call    0 returned 210
      210:  811:        if (output == NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 210
        -:  812:        {
    #####:  813:            goto fail; /* allocation failure */
        -:  814:        }
        -:  815:    }
        -:  816:
      210:  817:    output_pointer = output;
        -:  818:    /* loop through the string literal */
     1820:  819:    while (input_pointer < input_end)
branch  0 taken 1400
branch  1 taken 210 (fallthrough)
        -:  820:    {
     1400:  821:        if (*input_pointer != '\\')
branch  0 taken 1400 (fallthrough)
branch  1 taken 0
        -:  822:        {
     1400:  823:            *output_pointer++ = *input_pointer++;
        -:  824:        }
        -:  825:        /* escape sequence */
        -:  826:        else
        -:  827:        {
    #####:  828:            unsigned char sequence_length = 2;
    #####:  829:            if ((input_end - input_pointer) < 1)
branch  0 never executed
branch  1 never executed
        -:  830:            {
    #####:  831:                goto fail;
        -:  832:            }
        -:  833:
    #####:  834:            switch (input_pointer[1])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -:  835:            {
    #####:  836:                case 'b':
    #####:  837:                    *output_pointer++ = '\b';
    #####:  838:                    break;
    #####:  839:                case 'f':
    #####:  840:                    *output_pointer++ = '\f';
    #####:  841:                    break;
    #####:  842:                case 'n':
    #####:  843:                    *output_pointer++ = '\n';
    #####:  844:                    break;
    #####:  845:                case 'r':
    #####:  846:                    *output_pointer++ = '\r';
    #####:  847:                    break;
    #####:  848:                case 't':
    #####:  849:                    *output_pointer++ = '\t';
    #####:  850:                    break;
    #####:  851:                case '\"':
        -:  852:                case '\\':
        -:  853:                case '/':
    #####:  854:                    *output_pointer++ = input_pointer[1];
    #####:  855:                    break;
        -:  856:
        -:  857:                /* UTF-16 literal */
    #####:  858:                case 'u':
    #####:  859:                    sequence_length = utf16_literal_to_utf8(input_pointer, input_end, &output_pointer);
call    0 never executed
    #####:  860:                    if (sequence_length == 0)
branch  0 never executed
branch  1 never executed
        -:  861:                    {
        -:  862:                        /* failed to convert UTF16-literal to UTF-8 */
    #####:  863:                        goto fail;
        -:  864:                    }
    #####:  865:                    break;
        -:  866:
    #####:  867:                default:
    #####:  868:                    goto fail;
        -:  869:            }
    #####:  870:            input_pointer += sequence_length;
        -:  871:        }
        -:  872:    }
        -:  873:
        -:  874:    /* zero terminate the output */
      210:  875:    *output_pointer = '\0';
        -:  876:
      210:  877:    item->type = cJSON_String;
      210:  878:    item->valuestring = (char*)output;
        -:  879:
      210:  880:    input_buffer->offset = (size_t) (input_end - input_buffer->content);
      210:  881:    input_buffer->offset++;
        -:  882:
      210:  883:    return true;
        -:  884:
    #####:  885:fail:
    #####:  886:    if (output != NULL)
branch  0 never executed
branch  1 never executed
        -:  887:    {
    #####:  888:        input_buffer->hooks.deallocate(output);
call    0 never executed
        -:  889:    }
        -:  890:
    #####:  891:    if (input_pointer != NULL)
branch  0 never executed
branch  1 never executed
        -:  892:    {
    #####:  893:        input_buffer->offset = (size_t)(input_pointer - input_buffer->content);
        -:  894:    }
        -:  895:
    #####:  896:    return false;
        -:  897:}
        -:  898:
        -:  899:/* Render the cstring provided to an escaped version that can be printed. */
function print_string_ptr called 0 returned 0% blocks executed 0%
    #####:  900:static cJSON_bool print_string_ptr(const unsigned char * const input, printbuffer * const output_buffer)
        -:  901:{
    #####:  902:    const unsigned char *input_pointer = NULL;
    #####:  903:    unsigned char *output = NULL;
    #####:  904:    unsigned char *output_pointer = NULL;
    #####:  905:    size_t output_length = 0;
        -:  906:    /* numbers of additional characters needed for escaping */
    #####:  907:    size_t escape_characters = 0;
        -:  908:
    #####:  909:    if (output_buffer == NULL)
branch  0 never executed
branch  1 never executed
        -:  910:    {
    #####:  911:        return false;
        -:  912:    }
        -:  913:
        -:  914:    /* empty string */
    #####:  915:    if (input == NULL)
branch  0 never executed
branch  1 never executed
        -:  916:    {
    #####:  917:        output = ensure(output_buffer, sizeof("\"\""));
call    0 never executed
    #####:  918:        if (output == NULL)
branch  0 never executed
branch  1 never executed
        -:  919:        {
    #####:  920:            return false;
        -:  921:        }
    #####:  922:        strcpy((char*)output, "\"\"");
        -:  923:
    #####:  924:        return true;
        -:  925:    }
        -:  926:
        -:  927:    /* set "flag" to 1 if something needs to be escaped */
    #####:  928:    for (input_pointer = input; *input_pointer; input_pointer++)
branch  0 never executed
branch  1 never executed
        -:  929:    {
    #####:  930:        switch (*input_pointer)
branch  0 never executed
branch  1 never executed
        -:  931:        {
    #####:  932:            case '\"':
        -:  933:            case '\\':
        -:  934:            case '\b':
        -:  935:            case '\f':
        -:  936:            case '\n':
        -:  937:            case '\r':
        -:  938:            case '\t':
        -:  939:                /* one character escape sequence */
    #####:  940:                escape_characters++;
    #####:  941:                break;
    #####:  942:            default:
    #####:  943:                if (*input_pointer < 32)
branch  0 never executed
branch  1 never executed
        -:  944:                {
        -:  945:                    /* UTF-16 escape sequence uXXXX */
    #####:  946:                    escape_characters += 5;
        -:  947:                }
    #####:  948:                break;
        -:  949:        }
        -:  950:    }
    #####:  951:    output_length = (size_t)(input_pointer - input) + escape_characters;
        -:  952:
    #####:  953:    output = ensure(output_buffer, output_length + sizeof("\"\""));
call    0 never executed
    #####:  954:    if (output == NULL)
branch  0 never executed
branch  1 never executed
        -:  955:    {
    #####:  956:        return false;
        -:  957:    }
        -:  958:
        -:  959:    /* no characters have to be escaped */
    #####:  960:    if (escape_characters == 0)
branch  0 never executed
branch  1 never executed
        -:  961:    {
    #####:  962:        output[0] = '\"';
    #####:  963:        memcpy(output + 1, input, output_length);
    #####:  964:        output[output_length + 1] = '\"';
    #####:  965:        output[output_length + 2] = '\0';
        -:  966:
    #####:  967:        return true;
        -:  968:    }
        -:  969:
    #####:  970:    output[0] = '\"';
    #####:  971:    output_pointer = output + 1;
        -:  972:    /* copy the string */
    #####:  973:    for (input_pointer = input; *input_pointer != '\0'; (void)input_pointer++, output_pointer++)
branch  0 never executed
branch  1 never executed
        -:  974:    {
    #####:  975:        if ((*input_pointer > 31) && (*input_pointer != '\"') && (*input_pointer != '\\'))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:  976:        {
        -:  977:            /* normal character, copy */
    #####:  978:            *output_pointer = *input_pointer;
        -:  979:        }
        -:  980:        else
        -:  981:        {
        -:  982:            /* character needs to be escaped */
    #####:  983:            *output_pointer++ = '\\';
    #####:  984:            switch (*input_pointer)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -:  985:            {
    #####:  986:                case '\\':
    #####:  987:                    *output_pointer = '\\';
    #####:  988:                    break;
    #####:  989:                case '\"':
    #####:  990:                    *output_pointer = '\"';
    #####:  991:                    break;
    #####:  992:                case '\b':
    #####:  993:                    *output_pointer = 'b';
    #####:  994:                    break;
    #####:  995:                case '\f':
    #####:  996:                    *output_pointer = 'f';
    #####:  997:                    break;
    #####:  998:                case '\n':
    #####:  999:                    *output_pointer = 'n';
    #####: 1000:                    break;
    #####: 1001:                case '\r':
    #####: 1002:                    *output_pointer = 'r';
    #####: 1003:                    break;
    #####: 1004:                case '\t':
    #####: 1005:                    *output_pointer = 't';
    #####: 1006:                    break;
    #####: 1007:                default:
        -: 1008:                    /* escape and print as unicode codepoint */
    #####: 1009:                    sprintf((char*)output_pointer, "u%04x", *input_pointer);
    #####: 1010:                    output_pointer += 4;
    #####: 1011:                    break;
        -: 1012:            }
        -: 1013:        }
        -: 1014:    }
    #####: 1015:    output[output_length + 1] = '\"';
    #####: 1016:    output[output_length + 2] = '\0';
        -: 1017:
    #####: 1018:    return true;
        -: 1019:}
        -: 1020:
        -: 1021:/* Invoke print_string_ptr (which is useful) on an item. */
function print_string called 0 returned 0% blocks executed 0%
    #####: 1022:static cJSON_bool print_string(const cJSON * const item, printbuffer * const p)
        -: 1023:{
    #####: 1024:    return print_string_ptr((unsigned char*)item->valuestring, p);
call    0 never executed
        -: 1025:}
        -: 1026:
        -: 1027:/* Predeclare these prototypes. */
        -: 1028:static cJSON_bool parse_value(cJSON * const item, parse_buffer * const input_buffer);
        -: 1029:static cJSON_bool print_value(const cJSON * const item, printbuffer * const output_buffer);
        -: 1030:static cJSON_bool parse_array(cJSON * const item, parse_buffer * const input_buffer);
        -: 1031:static cJSON_bool print_array(const cJSON * const item, printbuffer * const output_buffer);
        -: 1032:static cJSON_bool parse_object(cJSON * const item, parse_buffer * const input_buffer);
        -: 1033:static cJSON_bool print_object(const cJSON * const item, printbuffer * const output_buffer);
        -: 1034:
        -: 1035:/* Utility to jump whitespace and cr/lf */
function buffer_skip_whitespace called 602 returned 100% blocks executed 80%
      602: 1036:static parse_buffer *buffer_skip_whitespace(parse_buffer * const buffer)
        -: 1037:{
      602: 1038:    if ((buffer == NULL) || (buffer->content == NULL))
branch  0 taken 602 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 602
        -: 1039:    {
    #####: 1040:        return NULL;
        -: 1041:    }
        -: 1042:
      602: 1043:    if (cannot_access_at_index(buffer, 0))
branch  0 taken 602 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 602
        -: 1044:    {
    #####: 1045:        return buffer;
        -: 1046:    }
        -: 1047:
     2562: 1048:    while (can_access_at_index(buffer, 0) && (buffer_at_offset(buffer)[0] <= 32))
branch  0 taken 1960 (fallthrough)
branch  1 taken 0
branch  2 taken 1960 (fallthrough)
branch  3 taken 0
branch  4 taken 1358
branch  5 taken 602 (fallthrough)
        -: 1049:    {
     1358: 1050:       buffer->offset++;
        -: 1051:    }
        -: 1052:
      602: 1053:    if (buffer->offset == buffer->length)
branch  0 taken 0 (fallthrough)
branch  1 taken 602
        -: 1054:    {
    #####: 1055:        buffer->offset--;
        -: 1056:    }
        -: 1057:	    
      602: 1058:    return buffer;
        -: 1059:}
        -: 1060:
        -: 1061:/* skip the UTF-8 BOM (byte order mark) if it is at the beginning of a buffer */
function skip_utf8_bom called 7 returned 100% blocks executed 80%
        7: 1062:static parse_buffer *skip_utf8_bom(parse_buffer * const buffer)
        -: 1063:{
        7: 1064:    if ((buffer == NULL) || (buffer->content == NULL) || (buffer->offset != 0))
branch  0 taken 7 (fallthrough)
branch  1 taken 0
branch  2 taken 7 (fallthrough)
branch  3 taken 0
branch  4 taken 0 (fallthrough)
branch  5 taken 7
        -: 1065:    {
    #####: 1066:        return NULL;
        -: 1067:    }
        -: 1068:
        7: 1069:    if (can_access_at_index(buffer, 4) && (strncmp((const char*)buffer_at_offset(buffer), "\xEF\xBB\xBF", 3) == 0))
branch  0 taken 7 (fallthrough)
branch  1 taken 0
branch  2 taken 7 (fallthrough)
branch  3 taken 0
branch  4 taken 0 (fallthrough)
branch  5 taken 7
        -: 1070:    {
    #####: 1071:        buffer->offset += 3;
        -: 1072:    }
        -: 1073:
        7: 1074:    return buffer;
        -: 1075:}
        -: 1076:
function cJSON_ParseWithOpts called 4 returned 100% blocks executed 75%
        4: 1077:CJSON_PUBLIC(cJSON *) cJSON_ParseWithOpts(const char *value, const char **return_parse_end, cJSON_bool require_null_terminated)
        -: 1078:{
        -: 1079:    size_t buffer_length;
        -: 1080:
        4: 1081:    if (NULL == value)
branch  0 taken 0 (fallthrough)
branch  1 taken 4
        -: 1082:    {
    #####: 1083:        return NULL;
        -: 1084:    }
        -: 1085:	
        -: 1086:    /* Adding null character size due to require_null_terminated. */
        4: 1087:    buffer_length = strlen(value) + sizeof("");
        -: 1088:
        4: 1089:    return cJSON_ParseWithLengthOpts(value, buffer_length, return_parse_end, require_null_terminated);
call    0 returned 4
        -: 1090:}
        -: 1091:
        -: 1092:/* Parse an object - create a new root, and populate. */
function cJSON_ParseWithLengthOpts called 7 returned 100% blocks executed 56%
        7: 1093:CJSON_PUBLIC(cJSON *) cJSON_ParseWithLengthOpts(const char *value, size_t buffer_length, const char **return_parse_end, cJSON_bool require_null_terminated)
        -: 1094:{
        7: 1095:    parse_buffer buffer = { 0, 0, 0, 0, { 0, 0, 0 } };
        7: 1096:    cJSON *item = NULL;
        -: 1097:
        -: 1098:    /* reset error position */
        7: 1099:    global_error.json = NULL;
        7: 1100:    global_error.position = 0;
        -: 1101:
        7: 1102:    if (value == NULL || 0 == buffer_length)
branch  0 taken 7 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 7
        -: 1103:    {
        -: 1104:        goto fail;
        -: 1105:    }
        -: 1106:
        7: 1107:    buffer.content = (const unsigned char*)value;
        7: 1108:    buffer.length = buffer_length; 
        7: 1109:    buffer.offset = 0;
        7: 1110:    buffer.hooks = global_hooks;
        -: 1111:
        7: 1112:    item = cJSON_New_Item(&global_hooks);
call    0 returned 7
        7: 1113:    if (item == NULL) /* memory fail */
branch  0 taken 0 (fallthrough)
branch  1 taken 7
        -: 1114:    {
    #####: 1115:        goto fail;
        -: 1116:    }
        -: 1117:
        7: 1118:    if (!parse_value(item, buffer_skip_whitespace(skip_utf8_bom(&buffer))))
call    0 returned 7
call    1 returned 7
call    2 returned 7
branch  3 taken 7 (fallthrough)
branch  4 taken 0
        -: 1119:    {
        -: 1120:        /* parse failure. ep is set. */
        7: 1121:        goto fail;
        -: 1122:    }
        -: 1123:
        -: 1124:    /* if we require null-terminated JSON without appended garbage, skip and then check for a null terminator */
    #####: 1125:    if (require_null_terminated)
branch  0 never executed
branch  1 never executed
        -: 1126:    {
    #####: 1127:        buffer_skip_whitespace(&buffer);
call    0 never executed
    #####: 1128:        if ((buffer.offset >= buffer.length) || buffer_at_offset(&buffer)[0] != '\0')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1129:        {
        -: 1130:            goto fail;
        -: 1131:        }
        -: 1132:    }
    #####: 1133:    if (return_parse_end)
branch  0 never executed
branch  1 never executed
        -: 1134:    {
    #####: 1135:        *return_parse_end = (const char*)buffer_at_offset(&buffer);
        -: 1136:    }
        -: 1137:
    #####: 1138:    return item;
        -: 1139:
    #####: 1140:fail:
        7: 1141:    if (item != NULL)
branch  0 taken 7 (fallthrough)
branch  1 taken 0
        -: 1142:    {
        7: 1143:        cJSON_Delete(item);
call    0 returned 7
        -: 1144:    }
        -: 1145:
        7: 1146:    if (value != NULL)
branch  0 taken 7 (fallthrough)
branch  1 taken 0
        -: 1147:    {
        -: 1148:        error local_error;
        7: 1149:        local_error.json = (const unsigned char*)value;
        7: 1150:        local_error.position = 0;
        -: 1151:
        7: 1152:        if (buffer.offset < buffer.length)
branch  0 taken 7 (fallthrough)
branch  1 taken 0
        -: 1153:        {
        7: 1154:            local_error.position = buffer.offset;
        -: 1155:        }
    #####: 1156:        else if (buffer.length > 0)
branch  0 never executed
branch  1 never executed
        -: 1157:        {
    #####: 1158:            local_error.position = buffer.length - 1;
        -: 1159:        }
        -: 1160:
        7: 1161:        if (return_parse_end != NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 7
        -: 1162:        {
    #####: 1163:            *return_parse_end = (const char*)local_error.json + local_error.position;
        -: 1164:        }
        -: 1165:
        7: 1166:        global_error = local_error;
        -: 1167:    }
        -: 1168:
        7: 1169:    return NULL;
        -: 1170:}
        -: 1171:
        -: 1172:/* Default options for cJSON_Parse */
function cJSON_Parse called 3 returned 100% blocks executed 100%
        3: 1173:CJSON_PUBLIC(cJSON *) cJSON_Parse(const char *value)
        -: 1174:{
        3: 1175:    return cJSON_ParseWithOpts(value, 0, 0);
call    0 returned 3
        -: 1176:}
        -: 1177:
function cJSON_ParseWithLength called 2 returned 100% blocks executed 100%
        2: 1178:CJSON_PUBLIC(cJSON *) cJSON_ParseWithLength(const char *value, size_t buffer_length)
        -: 1179:{
        2: 1180:    return cJSON_ParseWithLengthOpts(value, buffer_length, 0, 0);
call    0 returned 2
        -: 1181:}
        -: 1182:
        -: 1183:#define cjson_min(a, b) (((a) < (b)) ? (a) : (b))
        -: 1184:
function print called 0 returned 0% blocks executed 0%
    #####: 1185:static unsigned char *print(const cJSON * const item, cJSON_bool format, const internal_hooks * const hooks)
        -: 1186:{
        -: 1187:    static const size_t default_buffer_size = 256;
        -: 1188:    printbuffer buffer[1];
    #####: 1189:    unsigned char *printed = NULL;
        -: 1190:
    #####: 1191:    memset(buffer, 0, sizeof(buffer));
        -: 1192:
        -: 1193:    /* create buffer */
    #####: 1194:    buffer->buffer = (unsigned char*) hooks->allocate(default_buffer_size);
call    0 never executed
    #####: 1195:    buffer->length = default_buffer_size;
    #####: 1196:    buffer->format = format;
    #####: 1197:    buffer->hooks = *hooks;
    #####: 1198:    if (buffer->buffer == NULL)
branch  0 never executed
branch  1 never executed
        -: 1199:    {
    #####: 1200:        goto fail;
        -: 1201:    }
        -: 1202:
        -: 1203:    /* print the value */
    #####: 1204:    if (!print_value(item, buffer))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1205:    {
    #####: 1206:        goto fail;
        -: 1207:    }
    #####: 1208:    update_offset(buffer);
call    0 never executed
        -: 1209:
        -: 1210:    /* check if reallocate is available */
    #####: 1211:    if (hooks->reallocate != NULL)
branch  0 never executed
branch  1 never executed
        -: 1212:    {
    #####: 1213:        printed = (unsigned char*) hooks->reallocate(buffer->buffer, buffer->offset + 1);
call    0 never executed
    #####: 1214:        if (printed == NULL) {
branch  0 never executed
branch  1 never executed
    #####: 1215:            goto fail;
        -: 1216:        }
    #####: 1217:        buffer->buffer = NULL;
        -: 1218:    }
        -: 1219:    else /* otherwise copy the JSON over to a new buffer */
        -: 1220:    {
    #####: 1221:        printed = (unsigned char*) hooks->allocate(buffer->offset + 1);
call    0 never executed
    #####: 1222:        if (printed == NULL)
branch  0 never executed
branch  1 never executed
        -: 1223:        {
    #####: 1224:            goto fail;
        -: 1225:        }
    #####: 1226:        memcpy(printed, buffer->buffer, cjson_min(buffer->length, buffer->offset + 1));
    #####: 1227:        printed[buffer->offset] = '\0'; /* just to be sure */
        -: 1228:
        -: 1229:        /* free the buffer */
    #####: 1230:        hooks->deallocate(buffer->buffer);
call    0 never executed
        -: 1231:    }
        -: 1232:
    #####: 1233:    return printed;
        -: 1234:
    #####: 1235:fail:
    #####: 1236:    if (buffer->buffer != NULL)
branch  0 never executed
branch  1 never executed
        -: 1237:    {
    #####: 1238:        hooks->deallocate(buffer->buffer);
call    0 never executed
        -: 1239:    }
        -: 1240:
    #####: 1241:    if (printed != NULL)
branch  0 never executed
branch  1 never executed
        -: 1242:    {
    #####: 1243:        hooks->deallocate(printed);
call    0 never executed
        -: 1244:    }
        -: 1245:
    #####: 1246:    return NULL;
        -: 1247:}
        -: 1248:
        -: 1249:/* Render a cJSON item/entity/structure to text. */
function cJSON_Print called 0 returned 0% blocks executed 0%
    #####: 1250:CJSON_PUBLIC(char *) cJSON_Print(const cJSON *item)
        -: 1251:{
    #####: 1252:    return (char*)print(item, true, &global_hooks);
call    0 never executed
        -: 1253:}
        -: 1254:
function cJSON_PrintUnformatted called 0 returned 0% blocks executed 0%
    #####: 1255:CJSON_PUBLIC(char *) cJSON_PrintUnformatted(const cJSON *item)
        -: 1256:{
    #####: 1257:    return (char*)print(item, false, &global_hooks);
call    0 never executed
        -: 1258:}
        -: 1259:
function cJSON_PrintBuffered called 0 returned 0% blocks executed 0%
    #####: 1260:CJSON_PUBLIC(char *) cJSON_PrintBuffered(const cJSON *item, int prebuffer, cJSON_bool fmt)
        -: 1261:{
    #####: 1262:    printbuffer p = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };
        -: 1263:
    #####: 1264:    if (prebuffer < 0)
branch  0 never executed
branch  1 never executed
        -: 1265:    {
    #####: 1266:        return NULL;
        -: 1267:    }
        -: 1268:
    #####: 1269:    p.buffer = (unsigned char*)global_hooks.allocate((size_t)prebuffer);
call    0 never executed
    #####: 1270:    if (!p.buffer)
branch  0 never executed
branch  1 never executed
        -: 1271:    {
    #####: 1272:        return NULL;
        -: 1273:    }
        -: 1274:
    #####: 1275:    p.length = (size_t)prebuffer;
    #####: 1276:    p.offset = 0;
    #####: 1277:    p.noalloc = false;
    #####: 1278:    p.format = fmt;
    #####: 1279:    p.hooks = global_hooks;
        -: 1280:
    #####: 1281:    if (!print_value(item, &p))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1282:    {
    #####: 1283:        global_hooks.deallocate(p.buffer);
call    0 never executed
    #####: 1284:        return NULL;
        -: 1285:    }
        -: 1286:
    #####: 1287:    return (char*)p.buffer;
        -: 1288:}
        -: 1289:
function cJSON_PrintPreallocated called 0 returned 0% blocks executed 0%
    #####: 1290:CJSON_PUBLIC(cJSON_bool) cJSON_PrintPreallocated(cJSON *item, char *buffer, const int length, const cJSON_bool format)
        -: 1291:{
    #####: 1292:    printbuffer p = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };
        -: 1293:
    #####: 1294:    if ((length < 0) || (buffer == NULL))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1295:    {
    #####: 1296:        return false;
        -: 1297:    }
        -: 1298:
    #####: 1299:    p.buffer = (unsigned char*)buffer;
    #####: 1300:    p.length = (size_t)length;
    #####: 1301:    p.offset = 0;
    #####: 1302:    p.noalloc = true;
    #####: 1303:    p.format = format;
    #####: 1304:    p.hooks = global_hooks;
        -: 1305:
    #####: 1306:    return print_value(item, &p);
call    0 never executed
        -: 1307:}
        -: 1308:
        -: 1309:/* Parser core - when encountering text, process appropriately. */
function parse_value called 147 returned 100% blocks executed 83%
      147: 1310:static cJSON_bool parse_value(cJSON * const item, parse_buffer * const input_buffer)
        -: 1311:{
      147: 1312:    if ((input_buffer == NULL) || (input_buffer->content == NULL))
branch  0 taken 147 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 147
        -: 1313:    {
    #####: 1314:        return false; /* no input */
        -: 1315:    }
        -: 1316:
        -: 1317:    /* parse the different types of values */
        -: 1318:    /* null */
      147: 1319:    if (can_read(input_buffer, 4) && (strncmp((const char*)buffer_at_offset(input_buffer), "null", 4) == 0))
branch  0 taken 147 (fallthrough)
branch  1 taken 0
branch  2 taken 147 (fallthrough)
branch  3 taken 0
branch  4 taken 0 (fallthrough)
branch  5 taken 147
        -: 1320:    {
    #####: 1321:        item->type = cJSON_NULL;
    #####: 1322:        input_buffer->offset += 4;
    #####: 1323:        return true;
        -: 1324:    }
        -: 1325:    /* false */
      147: 1326:    if (can_read(input_buffer, 5) && (strncmp((const char*)buffer_at_offset(input_buffer), "false", 5) == 0))
branch  0 taken 147 (fallthrough)
branch  1 taken 0
branch  2 taken 147 (fallthrough)
branch  3 taken 0
branch  4 taken 0 (fallthrough)
branch  5 taken 147
        -: 1327:    {
    #####: 1328:        item->type = cJSON_False;
    #####: 1329:        input_buffer->offset += 5;
    #####: 1330:        return true;
        -: 1331:    }
        -: 1332:    /* true */
      147: 1333:    if (can_read(input_buffer, 4) && (strncmp((const char*)buffer_at_offset(input_buffer), "true", 4) == 0))
branch  0 taken 147 (fallthrough)
branch  1 taken 0
branch  2 taken 147 (fallthrough)
branch  3 taken 0
branch  4 taken 0 (fallthrough)
branch  5 taken 147
        -: 1334:    {
    #####: 1335:        item->type = cJSON_True;
    #####: 1336:        item->valueint = 1;
    #####: 1337:        input_buffer->offset += 4;
    #####: 1338:        return true;
        -: 1339:    }
        -: 1340:    /* string */
      147: 1341:    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '\"'))
branch  0 taken 147 (fallthrough)
branch  1 taken 0
branch  2 taken 147 (fallthrough)
branch  3 taken 0
branch  4 taken 63 (fallthrough)
branch  5 taken 84
        -: 1342:    {
       63: 1343:        return parse_string(item, input_buffer);
call    0 returned 63
        -: 1344:    }
        -: 1345:    /* number */
       84: 1346:    if (can_access_at_index(input_buffer, 0) && ((buffer_at_offset(input_buffer)[0] == '-') || ((buffer_at_offset(input_buffer)[0] >= '0') && (buffer_at_offset(input_buffer)[0] <= '9'))))
branch  0 taken 84 (fallthrough)
branch  1 taken 0
branch  2 taken 84 (fallthrough)
branch  3 taken 0
branch  4 taken 84 (fallthrough)
branch  5 taken 0
branch  6 taken 84 (fallthrough)
branch  7 taken 0
branch  8 taken 49 (fallthrough)
branch  9 taken 35
        -: 1347:    {
       49: 1348:        return parse_number(item, input_buffer);
call    0 returned 49
        -: 1349:    }
        -: 1350:    /* array */
       35: 1351:    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '['))
branch  0 taken 35 (fallthrough)
branch  1 taken 0
branch  2 taken 35 (fallthrough)
branch  3 taken 0
branch  4 taken 0 (fallthrough)
branch  5 taken 35
        -: 1352:    {
    #####: 1353:        return parse_array(item, input_buffer);
call    0 never executed
        -: 1354:    }
        -: 1355:    /* object */
       35: 1356:    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '{'))
branch  0 taken 35 (fallthrough)
branch  1 taken 0
branch  2 taken 35 (fallthrough)
branch  3 taken 0
branch  4 taken 35 (fallthrough)
branch  5 taken 0
        -: 1357:    {
       35: 1358:        return parse_object(item, input_buffer);
call    0 returned 35
        -: 1359:    }
        -: 1360:   
    #####: 1361:    return false;
        -: 1362:}
        -: 1363:
        -: 1364:/* Render a value to text. */
function print_value called 0 returned 0% blocks executed 0%
    #####: 1365:static cJSON_bool print_value(const cJSON * const item, printbuffer * const output_buffer)
        -: 1366:{
    #####: 1367:    unsigned char *output = NULL;
        -: 1368:
    #####: 1369:    if ((item == NULL) || (output_buffer == NULL))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1370:    {
    #####: 1371:        return false;
        -: 1372:    }
        -: 1373:
    #####: 1374:    switch ((item->type) & 0xFF)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
        -: 1375:    {
    #####: 1376:        case cJSON_NULL:
    #####: 1377:            output = ensure(output_buffer, 5);
call    0 never executed
    #####: 1378:            if (output == NULL)
branch  0 never executed
branch  1 never executed
        -: 1379:            {
    #####: 1380:                return false;
        -: 1381:            }
    #####: 1382:            strcpy((char*)output, "null");
    #####: 1383:            return true;
        -: 1384:
    #####: 1385:        case cJSON_False:
    #####: 1386:            output = ensure(output_buffer, 6);
call    0 never executed
    #####: 1387:            if (output == NULL)
branch  0 never executed
branch  1 never executed
        -: 1388:            {
    #####: 1389:                return false;
        -: 1390:            }
    #####: 1391:            strcpy((char*)output, "false");
    #####: 1392:            return true;
        -: 1393:
    #####: 1394:        case cJSON_True:
    #####: 1395:            output = ensure(output_buffer, 5);
call    0 never executed
    #####: 1396:            if (output == NULL)
branch  0 never executed
branch  1 never executed
        -: 1397:            {
    #####: 1398:                return false;
        -: 1399:            }
    #####: 1400:            strcpy((char*)output, "true");
    #####: 1401:            return true;
        -: 1402:
    #####: 1403:        case cJSON_Number:
    #####: 1404:            return print_number(item, output_buffer);
call    0 never executed
        -: 1405:
    #####: 1406:        case cJSON_Raw:
        -: 1407:        {
    #####: 1408:            size_t raw_length = 0;
    #####: 1409:            if (item->valuestring == NULL)
branch  0 never executed
branch  1 never executed
        -: 1410:            {
    #####: 1411:                return false;
        -: 1412:            }
        -: 1413:
    #####: 1414:            raw_length = strlen(item->valuestring) + sizeof("");
    #####: 1415:            output = ensure(output_buffer, raw_length);
call    0 never executed
    #####: 1416:            if (output == NULL)
branch  0 never executed
branch  1 never executed
        -: 1417:            {
    #####: 1418:                return false;
        -: 1419:            }
    #####: 1420:            memcpy(output, item->valuestring, raw_length);
    #####: 1421:            return true;
        -: 1422:        }
        -: 1423:
    #####: 1424:        case cJSON_String:
    #####: 1425:            return print_string(item, output_buffer);
call    0 never executed
        -: 1426:
    #####: 1427:        case cJSON_Array:
    #####: 1428:            return print_array(item, output_buffer);
call    0 never executed
        -: 1429:
    #####: 1430:        case cJSON_Object:
    #####: 1431:            return print_object(item, output_buffer);
call    0 never executed
        -: 1432:
    #####: 1433:        default:
    #####: 1434:            return false;
        -: 1435:    }
        -: 1436:}
        -: 1437:
        -: 1438:/* Build an array from input text. */
function parse_array called 0 returned 0% blocks executed 0%
    #####: 1439:static cJSON_bool parse_array(cJSON * const item, parse_buffer * const input_buffer)
        -: 1440:{
    #####: 1441:    cJSON *head = NULL; /* head of the linked list */
    #####: 1442:    cJSON *current_item = NULL;
        -: 1443:
    #####: 1444:    if (input_buffer->depth >= CJSON_NESTING_LIMIT)
branch  0 never executed
branch  1 never executed
        -: 1445:    {
    #####: 1446:        return false; /* to deeply nested */
        -: 1447:    }
    #####: 1448:    input_buffer->depth++;
        -: 1449:
    #####: 1450:    if (buffer_at_offset(input_buffer)[0] != '[')
branch  0 never executed
branch  1 never executed
        -: 1451:    {
        -: 1452:        /* not an array */
    #####: 1453:        goto fail;
        -: 1454:    }
        -: 1455:
    #####: 1456:    input_buffer->offset++;
    #####: 1457:    buffer_skip_whitespace(input_buffer);
call    0 never executed
    #####: 1458:    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ']'))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1459:    {
        -: 1460:        /* empty array */
    #####: 1461:        goto success;
        -: 1462:    }
        -: 1463:
        -: 1464:    /* check if we skipped to the end of the buffer */
    #####: 1465:    if (cannot_access_at_index(input_buffer, 0))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1466:    {
    #####: 1467:        input_buffer->offset--;
    #####: 1468:        goto fail;
        -: 1469:    }
        -: 1470:
        -: 1471:    /* step back to character in front of the first element */
    #####: 1472:    input_buffer->offset--;
        -: 1473:    /* loop through the comma separated array elements */
        -: 1474:    do
        -: 1475:    {
        -: 1476:        /* allocate next item */
    #####: 1477:        cJSON *new_item = cJSON_New_Item(&(input_buffer->hooks));
call    0 never executed
    #####: 1478:        if (new_item == NULL)
branch  0 never executed
branch  1 never executed
        -: 1479:        {
    #####: 1480:            goto fail; /* allocation failure */
        -: 1481:        }
        -: 1482:
        -: 1483:        /* attach next item to list */
    #####: 1484:        if (head == NULL)
branch  0 never executed
branch  1 never executed
        -: 1485:        {
        -: 1486:            /* start the linked list */
    #####: 1487:            current_item = head = new_item;
        -: 1488:        }
        -: 1489:        else
        -: 1490:        {
        -: 1491:            /* add to the end and advance */
    #####: 1492:            current_item->next = new_item;
    #####: 1493:            new_item->prev = current_item;
    #####: 1494:            current_item = new_item;
        -: 1495:        }
        -: 1496:
        -: 1497:        /* parse next value */
    #####: 1498:        input_buffer->offset++;
    #####: 1499:        buffer_skip_whitespace(input_buffer);
call    0 never executed
    #####: 1500:        if (!parse_value(current_item, input_buffer))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1501:        {
    #####: 1502:            goto fail; /* failed to parse value */
        -: 1503:        }
    #####: 1504:        buffer_skip_whitespace(input_buffer);
call    0 never executed
        -: 1505:    }
    #####: 1506:    while (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ','));
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1507:
    #####: 1508:    if (cannot_access_at_index(input_buffer, 0) || buffer_at_offset(input_buffer)[0] != ']')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1509:    {
        -: 1510:        goto fail; /* expected end of array */
        -: 1511:    }
        -: 1512:
    #####: 1513:success:
    #####: 1514:    input_buffer->depth--;
        -: 1515:
    #####: 1516:    if (head != NULL) {
branch  0 never executed
branch  1 never executed
    #####: 1517:        head->prev = current_item;
        -: 1518:    }
        -: 1519:
    #####: 1520:    item->type = cJSON_Array;
    #####: 1521:    item->child = head;
        -: 1522:
    #####: 1523:    input_buffer->offset++;
        -: 1524:
    #####: 1525:    return true;
        -: 1526:
    #####: 1527:fail:
    #####: 1528:    if (head != NULL)
branch  0 never executed
branch  1 never executed
        -: 1529:    {
    #####: 1530:        cJSON_Delete(head);
call    0 never executed
        -: 1531:    }
        -: 1532:
    #####: 1533:    return false;
        -: 1534:}
        -: 1535:
        -: 1536:/* Render an array to text */
function print_array called 0 returned 0% blocks executed 0%
    #####: 1537:static cJSON_bool print_array(const cJSON * const item, printbuffer * const output_buffer)
        -: 1538:{
    #####: 1539:    unsigned char *output_pointer = NULL;
    #####: 1540:    size_t length = 0;
    #####: 1541:    cJSON *current_element = item->child;
        -: 1542:
    #####: 1543:    if (output_buffer == NULL)
branch  0 never executed
branch  1 never executed
        -: 1544:    {
    #####: 1545:        return false;
        -: 1546:    }
        -: 1547:
        -: 1548:    /* Compose the output array. */
        -: 1549:    /* opening square bracket */
    #####: 1550:    output_pointer = ensure(output_buffer, 1);
call    0 never executed
    #####: 1551:    if (output_pointer == NULL)
branch  0 never executed
branch  1 never executed
        -: 1552:    {
    #####: 1553:        return false;
        -: 1554:    }
        -: 1555:
    #####: 1556:    *output_pointer = '[';
    #####: 1557:    output_buffer->offset++;
    #####: 1558:    output_buffer->depth++;
        -: 1559:
    #####: 1560:    while (current_element != NULL)
branch  0 never executed
branch  1 never executed
        -: 1561:    {
    #####: 1562:        if (!print_value(current_element, output_buffer))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1563:        {
    #####: 1564:            return false;
        -: 1565:        }
    #####: 1566:        update_offset(output_buffer);
call    0 never executed
    #####: 1567:        if (current_element->next)
branch  0 never executed
branch  1 never executed
        -: 1568:        {
    #####: 1569:            length = (size_t) (output_buffer->format ? 2 : 1);
branch  0 never executed
branch  1 never executed
    #####: 1570:            output_pointer = ensure(output_buffer, length + 1);
call    0 never executed
    #####: 1571:            if (output_pointer == NULL)
branch  0 never executed
branch  1 never executed
        -: 1572:            {
    #####: 1573:                return false;
        -: 1574:            }
    #####: 1575:            *output_pointer++ = ',';
    #####: 1576:            if(output_buffer->format)
branch  0 never executed
branch  1 never executed
        -: 1577:            {
    #####: 1578:                *output_pointer++ = ' ';
        -: 1579:            }
    #####: 1580:            *output_pointer = '\0';
    #####: 1581:            output_buffer->offset += length;
        -: 1582:        }
    #####: 1583:        current_element = current_element->next;
        -: 1584:    }
        -: 1585:
    #####: 1586:    output_pointer = ensure(output_buffer, 2);
call    0 never executed
    #####: 1587:    if (output_pointer == NULL)
branch  0 never executed
branch  1 never executed
        -: 1588:    {
    #####: 1589:        return false;
        -: 1590:    }
    #####: 1591:    *output_pointer++ = ']';
    #####: 1592:    *output_pointer = '\0';
    #####: 1593:    output_buffer->depth--;
        -: 1594:
    #####: 1595:    return true;
        -: 1596:}
        -: 1597:
        -: 1598:/* Build an object from the text. */
function parse_object called 35 returned 100% blocks executed 77%
       35: 1599:static cJSON_bool parse_object(cJSON * const item, parse_buffer * const input_buffer)
        -: 1600:{
       35: 1601:    cJSON *head = NULL; /* linked list head */
       35: 1602:    cJSON *current_item = NULL;
        -: 1603:
       35: 1604:    if (input_buffer->depth >= CJSON_NESTING_LIMIT)
branch  0 taken 0 (fallthrough)
branch  1 taken 35
        -: 1605:    {
    #####: 1606:        return false; /* to deeply nested */
        -: 1607:    }
       35: 1608:    input_buffer->depth++;
        -: 1609:
       70: 1610:    if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != '{'))
branch  0 taken 35 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 35
branch  4 taken 0 (fallthrough)
branch  5 taken 35
        -: 1611:    {
        -: 1612:        goto fail; /* not an object */
        -: 1613:    }
        -: 1614:
       35: 1615:    input_buffer->offset++;
       35: 1616:    buffer_skip_whitespace(input_buffer);
call    0 returned 35
       35: 1617:    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '}'))
branch  0 taken 35 (fallthrough)
branch  1 taken 0
branch  2 taken 35 (fallthrough)
branch  3 taken 0
branch  4 taken 0 (fallthrough)
branch  5 taken 35
        -: 1618:    {
    #####: 1619:        goto success; /* empty object */
        -: 1620:    }
        -: 1621:
        -: 1622:    /* check if we skipped to the end of the buffer */
       35: 1623:    if (cannot_access_at_index(input_buffer, 0))
branch  0 taken 35 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 35
        -: 1624:    {
    #####: 1625:        input_buffer->offset--;
    #####: 1626:        goto fail;
        -: 1627:    }
        -: 1628:
        -: 1629:    /* step back to character in front of the first element */
       35: 1630:    input_buffer->offset--;
        -: 1631:    /* loop through the comma separated array elements */
        -: 1632:    do
        -: 1633:    {
        -: 1634:        /* allocate next item */
      147: 1635:        cJSON *new_item = cJSON_New_Item(&(input_buffer->hooks));
call    0 returned 147
      147: 1636:        if (new_item == NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 147
        -: 1637:        {
    #####: 1638:            goto fail; /* allocation failure */
        -: 1639:        }
        -: 1640:
        -: 1641:        /* attach next item to list */
      147: 1642:        if (head == NULL)
branch  0 taken 35 (fallthrough)
branch  1 taken 112
        -: 1643:        {
        -: 1644:            /* start the linked list */
       35: 1645:            current_item = head = new_item;
        -: 1646:        }
        -: 1647:        else
        -: 1648:        {
        -: 1649:            /* add to the end and advance */
      112: 1650:            current_item->next = new_item;
      112: 1651:            new_item->prev = current_item;
      112: 1652:            current_item = new_item;
        -: 1653:        }
        -: 1654:
        -: 1655:        /* parse the name of the child */
      147: 1656:        input_buffer->offset++;
      147: 1657:        buffer_skip_whitespace(input_buffer);
call    0 returned 147
      147: 1658:        if (!parse_string(current_item, input_buffer))
call    0 returned 147
branch  1 taken 0 (fallthrough)
branch  2 taken 147
        -: 1659:        {
    #####: 1660:            goto fail; /* failed to parse name */
        -: 1661:        }
      147: 1662:        buffer_skip_whitespace(input_buffer);
call    0 returned 147
        -: 1663:
        -: 1664:        /* swap valuestring and string, because we parsed the name */
      147: 1665:        current_item->string = current_item->valuestring;
      147: 1666:        current_item->valuestring = NULL;
        -: 1667:
      441: 1668:        if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != ':'))
branch  0 taken 0 (fallthrough)
branch  1 taken 147
branch  2 taken 0 (fallthrough)
branch  3 taken 147
branch  4 taken 7 (fallthrough)
branch  5 taken 140
        -: 1669:        {
        -: 1670:            goto fail; /* invalid object */
        -: 1671:        }
        -: 1672:
        -: 1673:        /* parse the value */
      140: 1674:        input_buffer->offset++;
      140: 1675:        buffer_skip_whitespace(input_buffer);
call    0 returned 140
      140: 1676:        if (!parse_value(current_item, input_buffer))
call    0 returned 140
branch  1 taken 14 (fallthrough)
branch  2 taken 126
        -: 1677:        {
       14: 1678:            goto fail; /* failed to parse value */
        -: 1679:        }
      126: 1680:        buffer_skip_whitespace(input_buffer);
call    0 returned 126
        -: 1681:    }
      126: 1682:    while (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ','));
branch  0 taken 126 (fallthrough)
branch  1 taken 0
branch  2 taken 126 (fallthrough)
branch  3 taken 0
branch  4 taken 112
branch  5 taken 14 (fallthrough)
        -: 1683:
       42: 1684:    if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != '}'))
branch  0 taken 0 (fallthrough)
branch  1 taken 14
branch  2 taken 0 (fallthrough)
branch  3 taken 14
branch  4 taken 0 (fallthrough)
branch  5 taken 14
        -: 1685:    {
        -: 1686:        goto fail; /* expected end of object */
        -: 1687:    }
        -: 1688:
       14: 1689:success:
       14: 1690:    input_buffer->depth--;
        -: 1691:
       14: 1692:    if (head != NULL) {
branch  0 taken 14 (fallthrough)
branch  1 taken 0
       14: 1693:        head->prev = current_item;
        -: 1694:    }
        -: 1695:
       14: 1696:    item->type = cJSON_Object;
       14: 1697:    item->child = head;
        -: 1698:
       14: 1699:    input_buffer->offset++;
       14: 1700:    return true;
        -: 1701:
        7: 1702:fail:
       21: 1703:    if (head != NULL)
branch  0 taken 21 (fallthrough)
branch  1 taken 0
        -: 1704:    {
       21: 1705:        cJSON_Delete(head);
call    0 returned 21
        -: 1706:    }
        -: 1707:
       21: 1708:    return false;
        -: 1709:}
        -: 1710:
        -: 1711:/* Render an object to text. */
function print_object called 0 returned 0% blocks executed 0%
    #####: 1712:static cJSON_bool print_object(const cJSON * const item, printbuffer * const output_buffer)
        -: 1713:{
    #####: 1714:    unsigned char *output_pointer = NULL;
    #####: 1715:    size_t length = 0;
    #####: 1716:    cJSON *current_item = item->child;
        -: 1717:
    #####: 1718:    if (output_buffer == NULL)
branch  0 never executed
branch  1 never executed
        -: 1719:    {
    #####: 1720:        return false;
        -: 1721:    }
        -: 1722:
        -: 1723:    /* Compose the output: */
    #####: 1724:    length = (size_t) (output_buffer->format ? 2 : 1); /* fmt: {\n */
branch  0 never executed
branch  1 never executed
    #####: 1725:    output_pointer = ensure(output_buffer, length + 1);
call    0 never executed
    #####: 1726:    if (output_pointer == NULL)
branch  0 never executed
branch  1 never executed
        -: 1727:    {
    #####: 1728:        return false;
        -: 1729:    }
        -: 1730:
    #####: 1731:    *output_pointer++ = '{';
    #####: 1732:    output_buffer->depth++;
    #####: 1733:    if (output_buffer->format)
branch  0 never executed
branch  1 never executed
        -: 1734:    {
    #####: 1735:        *output_pointer++ = '\n';
        -: 1736:    }
    #####: 1737:    output_buffer->offset += length;
        -: 1738:
    #####: 1739:    while (current_item)
branch  0 never executed
branch  1 never executed
        -: 1740:    {
    #####: 1741:        if (output_buffer->format)
branch  0 never executed
branch  1 never executed
        -: 1742:        {
        -: 1743:            size_t i;
    #####: 1744:            output_pointer = ensure(output_buffer, output_buffer->depth);
call    0 never executed
    #####: 1745:            if (output_pointer == NULL)
branch  0 never executed
branch  1 never executed
        -: 1746:            {
    #####: 1747:                return false;
        -: 1748:            }
    #####: 1749:            for (i = 0; i < output_buffer->depth; i++)
branch  0 never executed
branch  1 never executed
        -: 1750:            {
    #####: 1751:                *output_pointer++ = '\t';
        -: 1752:            }
    #####: 1753:            output_buffer->offset += output_buffer->depth;
        -: 1754:        }
        -: 1755:
        -: 1756:        /* print key */
    #####: 1757:        if (!print_string_ptr((unsigned char*)current_item->string, output_buffer))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1758:        {
    #####: 1759:            return false;
        -: 1760:        }
    #####: 1761:        update_offset(output_buffer);
call    0 never executed
        -: 1762:
    #####: 1763:        length = (size_t) (output_buffer->format ? 2 : 1);
branch  0 never executed
branch  1 never executed
    #####: 1764:        output_pointer = ensure(output_buffer, length);
call    0 never executed
    #####: 1765:        if (output_pointer == NULL)
branch  0 never executed
branch  1 never executed
        -: 1766:        {
    #####: 1767:            return false;
        -: 1768:        }
    #####: 1769:        *output_pointer++ = ':';
    #####: 1770:        if (output_buffer->format)
branch  0 never executed
branch  1 never executed
        -: 1771:        {
    #####: 1772:            *output_pointer++ = '\t';
        -: 1773:        }
    #####: 1774:        output_buffer->offset += length;
        -: 1775:
        -: 1776:        /* print value */
    #####: 1777:        if (!print_value(current_item, output_buffer))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 1778:        {
    #####: 1779:            return false;
        -: 1780:        }
    #####: 1781:        update_offset(output_buffer);
call    0 never executed
        -: 1782:
        -: 1783:        /* print comma if not last */
    #####: 1784:        length = ((size_t)(output_buffer->format ? 1 : 0) + (size_t)(current_item->next ? 1 : 0));
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1785:        output_pointer = ensure(output_buffer, length + 1);
call    0 never executed
    #####: 1786:        if (output_pointer == NULL)
branch  0 never executed
branch  1 never executed
        -: 1787:        {
    #####: 1788:            return false;
        -: 1789:        }
    #####: 1790:        if (current_item->next)
branch  0 never executed
branch  1 never executed
        -: 1791:        {
    #####: 1792:            *output_pointer++ = ',';
        -: 1793:        }
        -: 1794:
    #####: 1795:        if (output_buffer->format)
branch  0 never executed
branch  1 never executed
        -: 1796:        {
    #####: 1797:            *output_pointer++ = '\n';
        -: 1798:        }
    #####: 1799:        *output_pointer = '\0';
    #####: 1800:        output_buffer->offset += length;
        -: 1801:
    #####: 1802:        current_item = current_item->next;
        -: 1803:    }
        -: 1804:
    #####: 1805:    output_pointer = ensure(output_buffer, output_buffer->format ? (output_buffer->depth + 1) : 2);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 1806:    if (output_pointer == NULL)
branch  0 never executed
branch  1 never executed
        -: 1807:    {
    #####: 1808:        return false;
        -: 1809:    }
    #####: 1810:    if (output_buffer->format)
branch  0 never executed
branch  1 never executed
        -: 1811:    {
        -: 1812:        size_t i;
    #####: 1813:        for (i = 0; i < (output_buffer->depth - 1); i++)
branch  0 never executed
branch  1 never executed
        -: 1814:        {
    #####: 1815:            *output_pointer++ = '\t';
        -: 1816:        }
        -: 1817:    }
    #####: 1818:    *output_pointer++ = '}';
    #####: 1819:    *output_pointer = '\0';
    #####: 1820:    output_buffer->depth--;
        -: 1821:
    #####: 1822:    return true;
        -: 1823:}
        -: 1824:
        -: 1825:/* Get Array size/item / object item. */
function cJSON_GetArraySize called 0 returned 0% blocks executed 0%
    #####: 1826:CJSON_PUBLIC(int) cJSON_GetArraySize(const cJSON *array)
        -: 1827:{
    #####: 1828:    cJSON *child = NULL;
    #####: 1829:    size_t size = 0;
        -: 1830:
    #####: 1831:    if (array == NULL)
branch  0 never executed
branch  1 never executed
        -: 1832:    {
    #####: 1833:        return 0;
        -: 1834:    }
        -: 1835:
    #####: 1836:    child = array->child;
        -: 1837:
    #####: 1838:    while(child != NULL)
branch  0 never executed
branch  1 never executed
        -: 1839:    {
    #####: 1840:        size++;
    #####: 1841:        child = child->next;
        -: 1842:    }
        -: 1843:
        -: 1844:    /* FIXME: Can overflow here. Cannot be fixed without breaking the API */
        -: 1845:
    #####: 1846:    return (int)size;
        -: 1847:}
        -: 1848:
function get_array_item called 0 returned 0% blocks executed 0%
    #####: 1849:static cJSON* get_array_item(const cJSON *array, size_t index)
        -: 1850:{
    #####: 1851:    cJSON *current_child = NULL;
        -: 1852:
    #####: 1853:    if (array == NULL)
branch  0 never executed
branch  1 never executed
        -: 1854:    {
    #####: 1855:        return NULL;
        -: 1856:    }
        -: 1857:
    #####: 1858:    current_child = array->child;
    #####: 1859:    while ((current_child != NULL) && (index > 0))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1860:    {
    #####: 1861:        index--;
    #####: 1862:        current_child = current_child->next;
        -: 1863:    }
        -: 1864:
    #####: 1865:    return current_child;
        -: 1866:}
        -: 1867:
function cJSON_GetArrayItem called 0 returned 0% blocks executed 0%
    #####: 1868:CJSON_PUBLIC(cJSON *) cJSON_GetArrayItem(const cJSON *array, int index)
        -: 1869:{
    #####: 1870:    if (index < 0)
branch  0 never executed
branch  1 never executed
        -: 1871:    {
    #####: 1872:        return NULL;
        -: 1873:    }
        -: 1874:
    #####: 1875:    return get_array_item(array, (size_t)index);
call    0 never executed
        -: 1876:}
        -: 1877:
function get_object_item called 0 returned 0% blocks executed 0%
    #####: 1878:static cJSON *get_object_item(const cJSON * const object, const char * const name, const cJSON_bool case_sensitive)
        -: 1879:{
    #####: 1880:    cJSON *current_element = NULL;
        -: 1881:
    #####: 1882:    if ((object == NULL) || (name == NULL))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1883:    {
    #####: 1884:        return NULL;
        -: 1885:    }
        -: 1886:
    #####: 1887:    current_element = object->child;
    #####: 1888:    if (case_sensitive)
branch  0 never executed
branch  1 never executed
        -: 1889:    {
    #####: 1890:        while ((current_element != NULL) && (current_element->string != NULL) && (strcmp(name, current_element->string) != 0))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1891:        {
    #####: 1892:            current_element = current_element->next;
        -: 1893:        }
        -: 1894:    }
        -: 1895:    else
        -: 1896:    {
    #####: 1897:        while ((current_element != NULL) && (case_insensitive_strcmp((const unsigned char*)name, (const unsigned char*)(current_element->string)) != 0))
branch  0 never executed
branch  1 never executed
call    2 never executed
branch  3 never executed
branch  4 never executed
        -: 1898:        {
    #####: 1899:            current_element = current_element->next;
        -: 1900:        }
        -: 1901:    }
        -: 1902:
    #####: 1903:    if ((current_element == NULL) || (current_element->string == NULL)) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1904:        return NULL;
        -: 1905:    }
        -: 1906:
    #####: 1907:    return current_element;
        -: 1908:}
        -: 1909:
function cJSON_GetObjectItem called 0 returned 0% blocks executed 0%
    #####: 1910:CJSON_PUBLIC(cJSON *) cJSON_GetObjectItem(const cJSON * const object, const char * const string)
        -: 1911:{
    #####: 1912:    return get_object_item(object, string, false);
call    0 never executed
        -: 1913:}
        -: 1914:
function cJSON_GetObjectItemCaseSensitive called 0 returned 0% blocks executed 0%
    #####: 1915:CJSON_PUBLIC(cJSON *) cJSON_GetObjectItemCaseSensitive(const cJSON * const object, const char * const string)
        -: 1916:{
    #####: 1917:    return get_object_item(object, string, true);
call    0 never executed
        -: 1918:}
        -: 1919:
function cJSON_HasObjectItem called 0 returned 0% blocks executed 0%
    #####: 1920:CJSON_PUBLIC(cJSON_bool) cJSON_HasObjectItem(const cJSON *object, const char *string)
        -: 1921:{
    #####: 1922:    return cJSON_GetObjectItem(object, string) ? 1 : 0;
call    0 never executed
        -: 1923:}
        -: 1924:
        -: 1925:/* Utility for array list handling. */
function suffix_object called 0 returned 0% blocks executed 0%
    #####: 1926:static void suffix_object(cJSON *prev, cJSON *item)
        -: 1927:{
    #####: 1928:    prev->next = item;
    #####: 1929:    item->prev = prev;
    #####: 1930:}
        -: 1931:
        -: 1932:/* Utility for handling references. */
function create_reference called 0 returned 0% blocks executed 0%
    #####: 1933:static cJSON *create_reference(const cJSON *item, const internal_hooks * const hooks)
        -: 1934:{
    #####: 1935:    cJSON *reference = NULL;
    #####: 1936:    if (item == NULL)
branch  0 never executed
branch  1 never executed
        -: 1937:    {
    #####: 1938:        return NULL;
        -: 1939:    }
        -: 1940:
    #####: 1941:    reference = cJSON_New_Item(hooks);
call    0 never executed
    #####: 1942:    if (reference == NULL)
branch  0 never executed
branch  1 never executed
        -: 1943:    {
    #####: 1944:        return NULL;
        -: 1945:    }
        -: 1946:
    #####: 1947:    memcpy(reference, item, sizeof(cJSON));
    #####: 1948:    reference->string = NULL;
    #####: 1949:    reference->type |= cJSON_IsReference;
    #####: 1950:    reference->next = reference->prev = NULL;
    #####: 1951:    return reference;
        -: 1952:}
        -: 1953:
function add_item_to_array called 0 returned 0% blocks executed 0%
    #####: 1954:static cJSON_bool add_item_to_array(cJSON *array, cJSON *item)
        -: 1955:{
    #####: 1956:    cJSON *child = NULL;
        -: 1957:
    #####: 1958:    if ((item == NULL) || (array == NULL) || (array == item))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 1959:    {
    #####: 1960:        return false;
        -: 1961:    }
        -: 1962:
    #####: 1963:    child = array->child;
        -: 1964:    /*
        -: 1965:     * To find the last item in array quickly, we use prev in array
        -: 1966:     */
    #####: 1967:    if (child == NULL)
branch  0 never executed
branch  1 never executed
        -: 1968:    {
        -: 1969:        /* list is empty, start new one */
    #####: 1970:        array->child = item;
    #####: 1971:        item->prev = item;
    #####: 1972:        item->next = NULL;
        -: 1973:    }
        -: 1974:    else
        -: 1975:    {
        -: 1976:        /* append to the end */
    #####: 1977:        if (child->prev)
branch  0 never executed
branch  1 never executed
        -: 1978:        {
    #####: 1979:            suffix_object(child->prev, item);
call    0 never executed
    #####: 1980:            array->child->prev = item;
        -: 1981:        }
        -: 1982:    }
        -: 1983:
    #####: 1984:    return true;
        -: 1985:}
        -: 1986:
        -: 1987:/* Add item to array/object. */
function cJSON_AddItemToArray called 0 returned 0% blocks executed 0%
    #####: 1988:CJSON_PUBLIC(cJSON_bool) cJSON_AddItemToArray(cJSON *array, cJSON *item)
        -: 1989:{
    #####: 1990:    return add_item_to_array(array, item);
call    0 never executed
        -: 1991:}
        -: 1992:
        -: 1993:#if defined(__clang__) || (defined(__GNUC__)  && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 5))))
        -: 1994:    #pragma GCC diagnostic push
        -: 1995:#endif
        -: 1996:#ifdef __GNUC__
        -: 1997:#pragma GCC diagnostic ignored "-Wcast-qual"
        -: 1998:#endif
        -: 1999:/* helper function to cast away const */
function cast_away_const called 0 returned 0% blocks executed 0%
    #####: 2000:static void* cast_away_const(const void* string)
        -: 2001:{
    #####: 2002:    return (void*)string;
        -: 2003:}
        -: 2004:#if defined(__clang__) || (defined(__GNUC__)  && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 5))))
        -: 2005:    #pragma GCC diagnostic pop
        -: 2006:#endif
        -: 2007:
        -: 2008:
function add_item_to_object called 0 returned 0% blocks executed 0%
    #####: 2009:static cJSON_bool add_item_to_object(cJSON * const object, const char * const string, cJSON * const item, const internal_hooks * const hooks, const cJSON_bool constant_key)
        -: 2010:{
    #####: 2011:    char *new_key = NULL;
    #####: 2012:    int new_type = cJSON_Invalid;
        -: 2013:
    #####: 2014:    if ((object == NULL) || (string == NULL) || (item == NULL) || (object == item))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -: 2015:    {
    #####: 2016:        return false;
        -: 2017:    }
        -: 2018:
    #####: 2019:    if (constant_key)
branch  0 never executed
branch  1 never executed
        -: 2020:    {
    #####: 2021:        new_key = (char*)cast_away_const(string);
call    0 never executed
    #####: 2022:        new_type = item->type | cJSON_StringIsConst;
        -: 2023:    }
        -: 2024:    else
        -: 2025:    {
    #####: 2026:        new_key = (char*)cJSON_strdup((const unsigned char*)string, hooks);
call    0 never executed
    #####: 2027:        if (new_key == NULL)
branch  0 never executed
branch  1 never executed
        -: 2028:        {
    #####: 2029:            return false;
        -: 2030:        }
        -: 2031:
    #####: 2032:        new_type = item->type & ~cJSON_StringIsConst;
        -: 2033:    }
        -: 2034:
    #####: 2035:    if (!(item->type & cJSON_StringIsConst) && (item->string != NULL))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2036:    {
    #####: 2037:        hooks->deallocate(item->string);
call    0 never executed
        -: 2038:    }
        -: 2039:
    #####: 2040:    item->string = new_key;
    #####: 2041:    item->type = new_type;
        -: 2042:
    #####: 2043:    return add_item_to_array(object, item);
call    0 never executed
        -: 2044:}
        -: 2045:
function cJSON_AddItemToObject called 0 returned 0% blocks executed 0%
    #####: 2046:CJSON_PUBLIC(cJSON_bool) cJSON_AddItemToObject(cJSON *object, const char *string, cJSON *item)
        -: 2047:{
    #####: 2048:    return add_item_to_object(object, string, item, &global_hooks, false);
call    0 never executed
        -: 2049:}
        -: 2050:
        -: 2051:/* Add an item to an object with constant string as key */
function cJSON_AddItemToObjectCS called 0 returned 0% blocks executed 0%
    #####: 2052:CJSON_PUBLIC(cJSON_bool) cJSON_AddItemToObjectCS(cJSON *object, const char *string, cJSON *item)
        -: 2053:{
    #####: 2054:    return add_item_to_object(object, string, item, &global_hooks, true);
call    0 never executed
        -: 2055:}
        -: 2056:
function cJSON_AddItemReferenceToArray called 0 returned 0% blocks executed 0%
    #####: 2057:CJSON_PUBLIC(cJSON_bool) cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)
        -: 2058:{
    #####: 2059:    if (array == NULL)
branch  0 never executed
branch  1 never executed
        -: 2060:    {
    #####: 2061:        return false;
        -: 2062:    }
        -: 2063:
    #####: 2064:    return add_item_to_array(array, create_reference(item, &global_hooks));
call    0 never executed
call    1 never executed
        -: 2065:}
        -: 2066:
function cJSON_AddItemReferenceToObject called 0 returned 0% blocks executed 0%
    #####: 2067:CJSON_PUBLIC(cJSON_bool) cJSON_AddItemReferenceToObject(cJSON *object, const char *string, cJSON *item)
        -: 2068:{
    #####: 2069:    if ((object == NULL) || (string == NULL))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2070:    {
    #####: 2071:        return false;
        -: 2072:    }
        -: 2073:
    #####: 2074:    return add_item_to_object(object, string, create_reference(item, &global_hooks), &global_hooks, false);
call    0 never executed
call    1 never executed
        -: 2075:}
        -: 2076:
function cJSON_AddNullToObject called 0 returned 0% blocks executed 0%
    #####: 2077:CJSON_PUBLIC(cJSON*) cJSON_AddNullToObject(cJSON * const object, const char * const name)
        -: 2078:{
    #####: 2079:    cJSON *null = cJSON_CreateNull();
call    0 never executed
    #####: 2080:    if (add_item_to_object(object, name, null, &global_hooks, false))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2081:    {
    #####: 2082:        return null;
        -: 2083:    }
        -: 2084:
    #####: 2085:    cJSON_Delete(null);
call    0 never executed
    #####: 2086:    return NULL;
        -: 2087:}
        -: 2088:
function cJSON_AddTrueToObject called 0 returned 0% blocks executed 0%
    #####: 2089:CJSON_PUBLIC(cJSON*) cJSON_AddTrueToObject(cJSON * const object, const char * const name)
        -: 2090:{
    #####: 2091:    cJSON *true_item = cJSON_CreateTrue();
call    0 never executed
    #####: 2092:    if (add_item_to_object(object, name, true_item, &global_hooks, false))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2093:    {
    #####: 2094:        return true_item;
        -: 2095:    }
        -: 2096:
    #####: 2097:    cJSON_Delete(true_item);
call    0 never executed
    #####: 2098:    return NULL;
        -: 2099:}
        -: 2100:
function cJSON_AddFalseToObject called 0 returned 0% blocks executed 0%
    #####: 2101:CJSON_PUBLIC(cJSON*) cJSON_AddFalseToObject(cJSON * const object, const char * const name)
        -: 2102:{
    #####: 2103:    cJSON *false_item = cJSON_CreateFalse();
call    0 never executed
    #####: 2104:    if (add_item_to_object(object, name, false_item, &global_hooks, false))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2105:    {
    #####: 2106:        return false_item;
        -: 2107:    }
        -: 2108:
    #####: 2109:    cJSON_Delete(false_item);
call    0 never executed
    #####: 2110:    return NULL;
        -: 2111:}
        -: 2112:
function cJSON_AddBoolToObject called 0 returned 0% blocks executed 0%
    #####: 2113:CJSON_PUBLIC(cJSON*) cJSON_AddBoolToObject(cJSON * const object, const char * const name, const cJSON_bool boolean)
        -: 2114:{
    #####: 2115:    cJSON *bool_item = cJSON_CreateBool(boolean);
call    0 never executed
    #####: 2116:    if (add_item_to_object(object, name, bool_item, &global_hooks, false))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2117:    {
    #####: 2118:        return bool_item;
        -: 2119:    }
        -: 2120:
    #####: 2121:    cJSON_Delete(bool_item);
call    0 never executed
    #####: 2122:    return NULL;
        -: 2123:}
        -: 2124:
function cJSON_AddNumberToObject called 0 returned 0% blocks executed 0%
    #####: 2125:CJSON_PUBLIC(cJSON*) cJSON_AddNumberToObject(cJSON * const object, const char * const name, const double number)
        -: 2126:{
    #####: 2127:    cJSON *number_item = cJSON_CreateNumber(number);
call    0 never executed
    #####: 2128:    if (add_item_to_object(object, name, number_item, &global_hooks, false))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2129:    {
    #####: 2130:        return number_item;
        -: 2131:    }
        -: 2132:
    #####: 2133:    cJSON_Delete(number_item);
call    0 never executed
    #####: 2134:    return NULL;
        -: 2135:}
        -: 2136:
function cJSON_AddStringToObject called 0 returned 0% blocks executed 0%
    #####: 2137:CJSON_PUBLIC(cJSON*) cJSON_AddStringToObject(cJSON * const object, const char * const name, const char * const string)
        -: 2138:{
    #####: 2139:    cJSON *string_item = cJSON_CreateString(string);
call    0 never executed
    #####: 2140:    if (add_item_to_object(object, name, string_item, &global_hooks, false))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2141:    {
    #####: 2142:        return string_item;
        -: 2143:    }
        -: 2144:
    #####: 2145:    cJSON_Delete(string_item);
call    0 never executed
    #####: 2146:    return NULL;
        -: 2147:}
        -: 2148:
function cJSON_AddRawToObject called 0 returned 0% blocks executed 0%
    #####: 2149:CJSON_PUBLIC(cJSON*) cJSON_AddRawToObject(cJSON * const object, const char * const name, const char * const raw)
        -: 2150:{
    #####: 2151:    cJSON *raw_item = cJSON_CreateRaw(raw);
call    0 never executed
    #####: 2152:    if (add_item_to_object(object, name, raw_item, &global_hooks, false))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2153:    {
    #####: 2154:        return raw_item;
        -: 2155:    }
        -: 2156:
    #####: 2157:    cJSON_Delete(raw_item);
call    0 never executed
    #####: 2158:    return NULL;
        -: 2159:}
        -: 2160:
function cJSON_AddObjectToObject called 0 returned 0% blocks executed 0%
    #####: 2161:CJSON_PUBLIC(cJSON*) cJSON_AddObjectToObject(cJSON * const object, const char * const name)
        -: 2162:{
    #####: 2163:    cJSON *object_item = cJSON_CreateObject();
call    0 never executed
    #####: 2164:    if (add_item_to_object(object, name, object_item, &global_hooks, false))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2165:    {
    #####: 2166:        return object_item;
        -: 2167:    }
        -: 2168:
    #####: 2169:    cJSON_Delete(object_item);
call    0 never executed
    #####: 2170:    return NULL;
        -: 2171:}
        -: 2172:
function cJSON_AddArrayToObject called 0 returned 0% blocks executed 0%
    #####: 2173:CJSON_PUBLIC(cJSON*) cJSON_AddArrayToObject(cJSON * const object, const char * const name)
        -: 2174:{
    #####: 2175:    cJSON *array = cJSON_CreateArray();
call    0 never executed
    #####: 2176:    if (add_item_to_object(object, name, array, &global_hooks, false))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 2177:    {
    #####: 2178:        return array;
        -: 2179:    }
        -: 2180:
    #####: 2181:    cJSON_Delete(array);
call    0 never executed
    #####: 2182:    return NULL;
        -: 2183:}
        -: 2184:
function cJSON_DetachItemViaPointer called 0 returned 0% blocks executed 0%
    #####: 2185:CJSON_PUBLIC(cJSON *) cJSON_DetachItemViaPointer(cJSON *parent, cJSON * const item)
        -: 2186:{
    #####: 2187:    if ((parent == NULL) || (item == NULL))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2188:    {
    #####: 2189:        return NULL;
        -: 2190:    }
        -: 2191:
    #####: 2192:    if (item != parent->child)
branch  0 never executed
branch  1 never executed
        -: 2193:    {
        -: 2194:        /* not the first element */
    #####: 2195:        item->prev->next = item->next;
        -: 2196:    }
    #####: 2197:    if (item->next != NULL)
branch  0 never executed
branch  1 never executed
        -: 2198:    {
        -: 2199:        /* not the last element */
    #####: 2200:        item->next->prev = item->prev;
        -: 2201:    }
        -: 2202:
    #####: 2203:    if (item == parent->child)
branch  0 never executed
branch  1 never executed
        -: 2204:    {
        -: 2205:        /* first element */
    #####: 2206:        parent->child = item->next;
        -: 2207:    }
    #####: 2208:    else if (item->next == NULL)
branch  0 never executed
branch  1 never executed
        -: 2209:    {
        -: 2210:        /* last element */
    #####: 2211:        parent->child->prev = item->prev;
        -: 2212:    }
        -: 2213:
        -: 2214:    /* make sure the detached item doesn't point anywhere anymore */
    #####: 2215:    item->prev = NULL;
    #####: 2216:    item->next = NULL;
        -: 2217:
    #####: 2218:    return item;
        -: 2219:}
        -: 2220:
function cJSON_DetachItemFromArray called 0 returned 0% blocks executed 0%
    #####: 2221:CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromArray(cJSON *array, int which)
        -: 2222:{
    #####: 2223:    if (which < 0)
branch  0 never executed
branch  1 never executed
        -: 2224:    {
    #####: 2225:        return NULL;
        -: 2226:    }
        -: 2227:
    #####: 2228:    return cJSON_DetachItemViaPointer(array, get_array_item(array, (size_t)which));
call    0 never executed
call    1 never executed
        -: 2229:}
        -: 2230:
function cJSON_DeleteItemFromArray called 0 returned 0% blocks executed 0%
    #####: 2231:CJSON_PUBLIC(void) cJSON_DeleteItemFromArray(cJSON *array, int which)
        -: 2232:{
    #####: 2233:    cJSON_Delete(cJSON_DetachItemFromArray(array, which));
call    0 never executed
call    1 never executed
    #####: 2234:}
        -: 2235:
function cJSON_DetachItemFromObject called 0 returned 0% blocks executed 0%
    #####: 2236:CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObject(cJSON *object, const char *string)
        -: 2237:{
    #####: 2238:    cJSON *to_detach = cJSON_GetObjectItem(object, string);
call    0 never executed
        -: 2239:
    #####: 2240:    return cJSON_DetachItemViaPointer(object, to_detach);
call    0 never executed
        -: 2241:}
        -: 2242:
function cJSON_DetachItemFromObjectCaseSensitive called 0 returned 0% blocks executed 0%
    #####: 2243:CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObjectCaseSensitive(cJSON *object, const char *string)
        -: 2244:{
    #####: 2245:    cJSON *to_detach = cJSON_GetObjectItemCaseSensitive(object, string);
call    0 never executed
        -: 2246:
    #####: 2247:    return cJSON_DetachItemViaPointer(object, to_detach);
call    0 never executed
        -: 2248:}
        -: 2249:
function cJSON_DeleteItemFromObject called 0 returned 0% blocks executed 0%
    #####: 2250:CJSON_PUBLIC(void) cJSON_DeleteItemFromObject(cJSON *object, const char *string)
        -: 2251:{
    #####: 2252:    cJSON_Delete(cJSON_DetachItemFromObject(object, string));
call    0 never executed
call    1 never executed
    #####: 2253:}
        -: 2254:
function cJSON_DeleteItemFromObjectCaseSensitive called 0 returned 0% blocks executed 0%
    #####: 2255:CJSON_PUBLIC(void) cJSON_DeleteItemFromObjectCaseSensitive(cJSON *object, const char *string)
        -: 2256:{
    #####: 2257:    cJSON_Delete(cJSON_DetachItemFromObjectCaseSensitive(object, string));
call    0 never executed
call    1 never executed
    #####: 2258:}
        -: 2259:
        -: 2260:/* Replace array/object items with new ones. */
function cJSON_InsertItemInArray called 0 returned 0% blocks executed 0%
    #####: 2261:CJSON_PUBLIC(cJSON_bool) cJSON_InsertItemInArray(cJSON *array, int which, cJSON *newitem)
        -: 2262:{
    #####: 2263:    cJSON *after_inserted = NULL;
        -: 2264:
    #####: 2265:    if (which < 0)
branch  0 never executed
branch  1 never executed
        -: 2266:    {
    #####: 2267:        return false;
        -: 2268:    }
        -: 2269:
    #####: 2270:    after_inserted = get_array_item(array, (size_t)which);
call    0 never executed
    #####: 2271:    if (after_inserted == NULL)
branch  0 never executed
branch  1 never executed
        -: 2272:    {
    #####: 2273:        return add_item_to_array(array, newitem);
call    0 never executed
        -: 2274:    }
        -: 2275:
    #####: 2276:    newitem->next = after_inserted;
    #####: 2277:    newitem->prev = after_inserted->prev;
    #####: 2278:    after_inserted->prev = newitem;
    #####: 2279:    if (after_inserted == array->child)
branch  0 never executed
branch  1 never executed
        -: 2280:    {
    #####: 2281:        array->child = newitem;
        -: 2282:    }
        -: 2283:    else
        -: 2284:    {
    #####: 2285:        newitem->prev->next = newitem;
        -: 2286:    }
    #####: 2287:    return true;
        -: 2288:}
        -: 2289:
function cJSON_ReplaceItemViaPointer called 0 returned 0% blocks executed 0%
    #####: 2290:CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemViaPointer(cJSON * const parent, cJSON * const item, cJSON * replacement)
        -: 2291:{
    #####: 2292:    if ((parent == NULL) || (replacement == NULL) || (item == NULL))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 2293:    {
    #####: 2294:        return false;
        -: 2295:    }
        -: 2296:
    #####: 2297:    if (replacement == item)
branch  0 never executed
branch  1 never executed
        -: 2298:    {
    #####: 2299:        return true;
        -: 2300:    }
        -: 2301:
    #####: 2302:    replacement->next = item->next;
    #####: 2303:    replacement->prev = item->prev;
        -: 2304:
    #####: 2305:    if (replacement->next != NULL)
branch  0 never executed
branch  1 never executed
        -: 2306:    {
    #####: 2307:        replacement->next->prev = replacement;
        -: 2308:    }
    #####: 2309:    if (parent->child == item)
branch  0 never executed
branch  1 never executed
        -: 2310:    {
    #####: 2311:        if (parent->child->prev == parent->child)
branch  0 never executed
branch  1 never executed
        -: 2312:        {
    #####: 2313:            replacement->prev = replacement;
        -: 2314:        }
    #####: 2315:        parent->child = replacement;
        -: 2316:    }
        -: 2317:    else
        -: 2318:    {   /*
        -: 2319:         * To find the last item in array quickly, we use prev in array.
        -: 2320:         * We can't modify the last item's next pointer where this item was the parent's child
        -: 2321:         */
    #####: 2322:        if (replacement->prev != NULL)
branch  0 never executed
branch  1 never executed
        -: 2323:        {
    #####: 2324:            replacement->prev->next = replacement;
        -: 2325:        }
    #####: 2326:        if (replacement->next == NULL)
branch  0 never executed
branch  1 never executed
        -: 2327:        {
    #####: 2328:            parent->child->prev = replacement;
        -: 2329:        }
        -: 2330:    }
        -: 2331:
    #####: 2332:    item->next = NULL;
    #####: 2333:    item->prev = NULL;
    #####: 2334:    cJSON_Delete(item);
call    0 never executed
        -: 2335:
    #####: 2336:    return true;
        -: 2337:}
        -: 2338:
function cJSON_ReplaceItemInArray called 0 returned 0% blocks executed 0%
    #####: 2339:CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemInArray(cJSON *array, int which, cJSON *newitem)
        -: 2340:{
    #####: 2341:    if (which < 0)
branch  0 never executed
branch  1 never executed
        -: 2342:    {
    #####: 2343:        return false;
        -: 2344:    }
        -: 2345:
    #####: 2346:    return cJSON_ReplaceItemViaPointer(array, get_array_item(array, (size_t)which), newitem);
call    0 never executed
call    1 never executed
        -: 2347:}
        -: 2348:
function replace_item_in_object called 0 returned 0% blocks executed 0%
    #####: 2349:static cJSON_bool replace_item_in_object(cJSON *object, const char *string, cJSON *replacement, cJSON_bool case_sensitive)
        -: 2350:{
    #####: 2351:    if ((replacement == NULL) || (string == NULL))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2352:    {
    #####: 2353:        return false;
        -: 2354:    }
        -: 2355:
        -: 2356:    /* replace the name in the replacement */
    #####: 2357:    if (!(replacement->type & cJSON_StringIsConst) && (replacement->string != NULL))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2358:    {
    #####: 2359:        cJSON_free(replacement->string);
call    0 never executed
        -: 2360:    }
    #####: 2361:    replacement->string = (char*)cJSON_strdup((const unsigned char*)string, &global_hooks);
call    0 never executed
    #####: 2362:    replacement->type &= ~cJSON_StringIsConst;
        -: 2363:
    #####: 2364:    return cJSON_ReplaceItemViaPointer(object, get_object_item(object, string, case_sensitive), replacement);
call    0 never executed
call    1 never executed
        -: 2365:}
        -: 2366:
function cJSON_ReplaceItemInObject called 0 returned 0% blocks executed 0%
    #####: 2367:CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemInObject(cJSON *object, const char *string, cJSON *newitem)
        -: 2368:{
    #####: 2369:    return replace_item_in_object(object, string, newitem, false);
call    0 never executed
        -: 2370:}
        -: 2371:
function cJSON_ReplaceItemInObjectCaseSensitive called 0 returned 0% blocks executed 0%
    #####: 2372:CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemInObjectCaseSensitive(cJSON *object, const char *string, cJSON *newitem)
        -: 2373:{
    #####: 2374:    return replace_item_in_object(object, string, newitem, true);
call    0 never executed
        -: 2375:}
        -: 2376:
        -: 2377:/* Create basic types: */
function cJSON_CreateNull called 0 returned 0% blocks executed 0%
    #####: 2378:CJSON_PUBLIC(cJSON *) cJSON_CreateNull(void)
        -: 2379:{
    #####: 2380:    cJSON *item = cJSON_New_Item(&global_hooks);
call    0 never executed
    #####: 2381:    if(item)
branch  0 never executed
branch  1 never executed
        -: 2382:    {
    #####: 2383:        item->type = cJSON_NULL;
        -: 2384:    }
        -: 2385:
    #####: 2386:    return item;
        -: 2387:}
        -: 2388:
function cJSON_CreateTrue called 0 returned 0% blocks executed 0%
    #####: 2389:CJSON_PUBLIC(cJSON *) cJSON_CreateTrue(void)
        -: 2390:{
    #####: 2391:    cJSON *item = cJSON_New_Item(&global_hooks);
call    0 never executed
    #####: 2392:    if(item)
branch  0 never executed
branch  1 never executed
        -: 2393:    {
    #####: 2394:        item->type = cJSON_True;
        -: 2395:    }
        -: 2396:
    #####: 2397:    return item;
        -: 2398:}
        -: 2399:
function cJSON_CreateFalse called 0 returned 0% blocks executed 0%
    #####: 2400:CJSON_PUBLIC(cJSON *) cJSON_CreateFalse(void)
        -: 2401:{
    #####: 2402:    cJSON *item = cJSON_New_Item(&global_hooks);
call    0 never executed
    #####: 2403:    if(item)
branch  0 never executed
branch  1 never executed
        -: 2404:    {
    #####: 2405:        item->type = cJSON_False;
        -: 2406:    }
        -: 2407:
    #####: 2408:    return item;
        -: 2409:}
        -: 2410:
function cJSON_CreateBool called 0 returned 0% blocks executed 0%
    #####: 2411:CJSON_PUBLIC(cJSON *) cJSON_CreateBool(cJSON_bool boolean)
        -: 2412:{
    #####: 2413:    cJSON *item = cJSON_New_Item(&global_hooks);
call    0 never executed
    #####: 2414:    if(item)
branch  0 never executed
branch  1 never executed
        -: 2415:    {
    #####: 2416:        item->type = boolean ? cJSON_True : cJSON_False;
branch  0 never executed
branch  1 never executed
        -: 2417:    }
        -: 2418:
    #####: 2419:    return item;
        -: 2420:}
        -: 2421:
function cJSON_CreateNumber called 0 returned 0% blocks executed 0%
    #####: 2422:CJSON_PUBLIC(cJSON *) cJSON_CreateNumber(double num)
        -: 2423:{
    #####: 2424:    cJSON *item = cJSON_New_Item(&global_hooks);
call    0 never executed
    #####: 2425:    if(item)
branch  0 never executed
branch  1 never executed
        -: 2426:    {
    #####: 2427:        item->type = cJSON_Number;
    #####: 2428:        item->valuedouble = num;
        -: 2429:
        -: 2430:        /* use saturation in case of overflow */
    #####: 2431:        if (num >= INT_MAX)
branch  0 never executed
branch  1 never executed
        -: 2432:        {
    #####: 2433:            item->valueint = INT_MAX;
        -: 2434:        }
    #####: 2435:        else if (num <= (double)INT_MIN)
branch  0 never executed
branch  1 never executed
        -: 2436:        {
    #####: 2437:            item->valueint = INT_MIN;
        -: 2438:        }
        -: 2439:        else
        -: 2440:        {
    #####: 2441:            item->valueint = (int)num;
        -: 2442:        }
        -: 2443:    }
        -: 2444:
    #####: 2445:    return item;
        -: 2446:}
        -: 2447:
function cJSON_CreateString called 0 returned 0% blocks executed 0%
    #####: 2448:CJSON_PUBLIC(cJSON *) cJSON_CreateString(const char *string)
        -: 2449:{
    #####: 2450:    cJSON *item = cJSON_New_Item(&global_hooks);
call    0 never executed
    #####: 2451:    if(item)
branch  0 never executed
branch  1 never executed
        -: 2452:    {
    #####: 2453:        item->type = cJSON_String;
    #####: 2454:        item->valuestring = (char*)cJSON_strdup((const unsigned char*)string, &global_hooks);
call    0 never executed
    #####: 2455:        if(!item->valuestring)
branch  0 never executed
branch  1 never executed
        -: 2456:        {
    #####: 2457:            cJSON_Delete(item);
call    0 never executed
    #####: 2458:            return NULL;
        -: 2459:        }
        -: 2460:    }
        -: 2461:
    #####: 2462:    return item;
        -: 2463:}
        -: 2464:
function cJSON_CreateStringReference called 0 returned 0% blocks executed 0%
    #####: 2465:CJSON_PUBLIC(cJSON *) cJSON_CreateStringReference(const char *string)
        -: 2466:{
    #####: 2467:    cJSON *item = cJSON_New_Item(&global_hooks);
call    0 never executed
    #####: 2468:    if (item != NULL)
branch  0 never executed
branch  1 never executed
        -: 2469:    {
    #####: 2470:        item->type = cJSON_String | cJSON_IsReference;
    #####: 2471:        item->valuestring = (char*)cast_away_const(string);
call    0 never executed
        -: 2472:    }
        -: 2473:
    #####: 2474:    return item;
        -: 2475:}
        -: 2476:
function cJSON_CreateObjectReference called 0 returned 0% blocks executed 0%
    #####: 2477:CJSON_PUBLIC(cJSON *) cJSON_CreateObjectReference(const cJSON *child)
        -: 2478:{
    #####: 2479:    cJSON *item = cJSON_New_Item(&global_hooks);
call    0 never executed
    #####: 2480:    if (item != NULL) {
branch  0 never executed
branch  1 never executed
    #####: 2481:        item->type = cJSON_Object | cJSON_IsReference;
    #####: 2482:        item->child = (cJSON*)cast_away_const(child);
call    0 never executed
        -: 2483:    }
        -: 2484:
    #####: 2485:    return item;
        -: 2486:}
        -: 2487:
function cJSON_CreateArrayReference called 0 returned 0% blocks executed 0%
    #####: 2488:CJSON_PUBLIC(cJSON *) cJSON_CreateArrayReference(const cJSON *child) {
    #####: 2489:    cJSON *item = cJSON_New_Item(&global_hooks);
call    0 never executed
    #####: 2490:    if (item != NULL) {
branch  0 never executed
branch  1 never executed
    #####: 2491:        item->type = cJSON_Array | cJSON_IsReference;
    #####: 2492:        item->child = (cJSON*)cast_away_const(child);
call    0 never executed
        -: 2493:    }
        -: 2494:
    #####: 2495:    return item;
        -: 2496:}
        -: 2497:
function cJSON_CreateRaw called 0 returned 0% blocks executed 0%
    #####: 2498:CJSON_PUBLIC(cJSON *) cJSON_CreateRaw(const char *raw)
        -: 2499:{
    #####: 2500:    cJSON *item = cJSON_New_Item(&global_hooks);
call    0 never executed
    #####: 2501:    if(item)
branch  0 never executed
branch  1 never executed
        -: 2502:    {
    #####: 2503:        item->type = cJSON_Raw;
    #####: 2504:        item->valuestring = (char*)cJSON_strdup((const unsigned char*)raw, &global_hooks);
call    0 never executed
    #####: 2505:        if(!item->valuestring)
branch  0 never executed
branch  1 never executed
        -: 2506:        {
    #####: 2507:            cJSON_Delete(item);
call    0 never executed
    #####: 2508:            return NULL;
        -: 2509:        }
        -: 2510:    }
        -: 2511:
    #####: 2512:    return item;
        -: 2513:}
        -: 2514:
function cJSON_CreateArray called 0 returned 0% blocks executed 0%
    #####: 2515:CJSON_PUBLIC(cJSON *) cJSON_CreateArray(void)
        -: 2516:{
    #####: 2517:    cJSON *item = cJSON_New_Item(&global_hooks);
call    0 never executed
    #####: 2518:    if(item)
branch  0 never executed
branch  1 never executed
        -: 2519:    {
    #####: 2520:        item->type=cJSON_Array;
        -: 2521:    }
        -: 2522:
    #####: 2523:    return item;
        -: 2524:}
        -: 2525:
function cJSON_CreateObject called 0 returned 0% blocks executed 0%
    #####: 2526:CJSON_PUBLIC(cJSON *) cJSON_CreateObject(void)
        -: 2527:{
    #####: 2528:    cJSON *item = cJSON_New_Item(&global_hooks);
call    0 never executed
    #####: 2529:    if (item)
branch  0 never executed
branch  1 never executed
        -: 2530:    {
    #####: 2531:        item->type = cJSON_Object;
        -: 2532:    }
        -: 2533:
    #####: 2534:    return item;
        -: 2535:}
        -: 2536:
        -: 2537:/* Create Arrays: */
function cJSON_CreateIntArray called 0 returned 0% blocks executed 0%
    #####: 2538:CJSON_PUBLIC(cJSON *) cJSON_CreateIntArray(const int *numbers, int count)
        -: 2539:{
    #####: 2540:    size_t i = 0;
    #####: 2541:    cJSON *n = NULL;
    #####: 2542:    cJSON *p = NULL;
    #####: 2543:    cJSON *a = NULL;
        -: 2544:
    #####: 2545:    if ((count < 0) || (numbers == NULL))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2546:    {
    #####: 2547:        return NULL;
        -: 2548:    }
        -: 2549:
    #####: 2550:    a = cJSON_CreateArray();
call    0 never executed
        -: 2551:
    #####: 2552:    for(i = 0; a && (i < (size_t)count); i++)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2553:    {
    #####: 2554:        n = cJSON_CreateNumber(numbers[i]);
call    0 never executed
    #####: 2555:        if (!n)
branch  0 never executed
branch  1 never executed
        -: 2556:        {
    #####: 2557:            cJSON_Delete(a);
call    0 never executed
    #####: 2558:            return NULL;
        -: 2559:        }
    #####: 2560:        if(!i)
branch  0 never executed
branch  1 never executed
        -: 2561:        {
    #####: 2562:            a->child = n;
        -: 2563:        }
        -: 2564:        else
        -: 2565:        {
    #####: 2566:            suffix_object(p, n);
call    0 never executed
        -: 2567:        }
    #####: 2568:        p = n;
        -: 2569:    }
        -: 2570:
    #####: 2571:    if (a && a->child) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2572:        a->child->prev = n;
        -: 2573:    }
        -: 2574:
    #####: 2575:    return a;
        -: 2576:}
        -: 2577:
function cJSON_CreateFloatArray called 0 returned 0% blocks executed 0%
    #####: 2578:CJSON_PUBLIC(cJSON *) cJSON_CreateFloatArray(const float *numbers, int count)
        -: 2579:{
    #####: 2580:    size_t i = 0;
    #####: 2581:    cJSON *n = NULL;
    #####: 2582:    cJSON *p = NULL;
    #####: 2583:    cJSON *a = NULL;
        -: 2584:
    #####: 2585:    if ((count < 0) || (numbers == NULL))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2586:    {
    #####: 2587:        return NULL;
        -: 2588:    }
        -: 2589:
    #####: 2590:    a = cJSON_CreateArray();
call    0 never executed
        -: 2591:
    #####: 2592:    for(i = 0; a && (i < (size_t)count); i++)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2593:    {
    #####: 2594:        n = cJSON_CreateNumber((double)numbers[i]);
call    0 never executed
    #####: 2595:        if(!n)
branch  0 never executed
branch  1 never executed
        -: 2596:        {
    #####: 2597:            cJSON_Delete(a);
call    0 never executed
    #####: 2598:            return NULL;
        -: 2599:        }
    #####: 2600:        if(!i)
branch  0 never executed
branch  1 never executed
        -: 2601:        {
    #####: 2602:            a->child = n;
        -: 2603:        }
        -: 2604:        else
        -: 2605:        {
    #####: 2606:            suffix_object(p, n);
call    0 never executed
        -: 2607:        }
    #####: 2608:        p = n;
        -: 2609:    }
        -: 2610:
    #####: 2611:    if (a && a->child) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2612:        a->child->prev = n;
        -: 2613:    }
        -: 2614:
    #####: 2615:    return a;
        -: 2616:}
        -: 2617:
function cJSON_CreateDoubleArray called 0 returned 0% blocks executed 0%
    #####: 2618:CJSON_PUBLIC(cJSON *) cJSON_CreateDoubleArray(const double *numbers, int count)
        -: 2619:{
    #####: 2620:    size_t i = 0;
    #####: 2621:    cJSON *n = NULL;
    #####: 2622:    cJSON *p = NULL;
    #####: 2623:    cJSON *a = NULL;
        -: 2624:
    #####: 2625:    if ((count < 0) || (numbers == NULL))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2626:    {
    #####: 2627:        return NULL;
        -: 2628:    }
        -: 2629:
    #####: 2630:    a = cJSON_CreateArray();
call    0 never executed
        -: 2631:
    #####: 2632:    for(i = 0; a && (i < (size_t)count); i++)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2633:    {
    #####: 2634:        n = cJSON_CreateNumber(numbers[i]);
call    0 never executed
    #####: 2635:        if(!n)
branch  0 never executed
branch  1 never executed
        -: 2636:        {
    #####: 2637:            cJSON_Delete(a);
call    0 never executed
    #####: 2638:            return NULL;
        -: 2639:        }
    #####: 2640:        if(!i)
branch  0 never executed
branch  1 never executed
        -: 2641:        {
    #####: 2642:            a->child = n;
        -: 2643:        }
        -: 2644:        else
        -: 2645:        {
    #####: 2646:            suffix_object(p, n);
call    0 never executed
        -: 2647:        }
    #####: 2648:        p = n;
        -: 2649:    }
        -: 2650:
    #####: 2651:    if (a && a->child) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2652:        a->child->prev = n;
        -: 2653:    }
        -: 2654:
    #####: 2655:    return a;
        -: 2656:}
        -: 2657:
function cJSON_CreateStringArray called 0 returned 0% blocks executed 0%
    #####: 2658:CJSON_PUBLIC(cJSON *) cJSON_CreateStringArray(const char *const *strings, int count)
        -: 2659:{
    #####: 2660:    size_t i = 0;
    #####: 2661:    cJSON *n = NULL;
    #####: 2662:    cJSON *p = NULL;
    #####: 2663:    cJSON *a = NULL;
        -: 2664:
    #####: 2665:    if ((count < 0) || (strings == NULL))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2666:    {
    #####: 2667:        return NULL;
        -: 2668:    }
        -: 2669:
    #####: 2670:    a = cJSON_CreateArray();
call    0 never executed
        -: 2671:
    #####: 2672:    for (i = 0; a && (i < (size_t)count); i++)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2673:    {
    #####: 2674:        n = cJSON_CreateString(strings[i]);
call    0 never executed
    #####: 2675:        if(!n)
branch  0 never executed
branch  1 never executed
        -: 2676:        {
    #####: 2677:            cJSON_Delete(a);
call    0 never executed
    #####: 2678:            return NULL;
        -: 2679:        }
    #####: 2680:        if(!i)
branch  0 never executed
branch  1 never executed
        -: 2681:        {
    #####: 2682:            a->child = n;
        -: 2683:        }
        -: 2684:        else
        -: 2685:        {
    #####: 2686:            suffix_object(p,n);
call    0 never executed
        -: 2687:        }
    #####: 2688:        p = n;
        -: 2689:    }
        -: 2690:
    #####: 2691:    if (a && a->child) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2692:        a->child->prev = n;
        -: 2693:    }
        -: 2694:    
    #####: 2695:    return a;
        -: 2696:}
        -: 2697:
        -: 2698:/* Duplication */
function cJSON_Duplicate called 0 returned 0% blocks executed 0%
    #####: 2699:CJSON_PUBLIC(cJSON *) cJSON_Duplicate(const cJSON *item, cJSON_bool recurse)
        -: 2700:{
    #####: 2701:    cJSON *newitem = NULL;
    #####: 2702:    cJSON *child = NULL;
    #####: 2703:    cJSON *next = NULL;
    #####: 2704:    cJSON *newchild = NULL;
        -: 2705:
        -: 2706:    /* Bail on bad ptr */
    #####: 2707:    if (!item)
branch  0 never executed
branch  1 never executed
        -: 2708:    {
    #####: 2709:        goto fail;
        -: 2710:    }
        -: 2711:    /* Create new item */
    #####: 2712:    newitem = cJSON_New_Item(&global_hooks);
call    0 never executed
    #####: 2713:    if (!newitem)
branch  0 never executed
branch  1 never executed
        -: 2714:    {
    #####: 2715:        goto fail;
        -: 2716:    }
        -: 2717:    /* Copy over all vars */
    #####: 2718:    newitem->type = item->type & (~cJSON_IsReference);
    #####: 2719:    newitem->valueint = item->valueint;
    #####: 2720:    newitem->valuedouble = item->valuedouble;
    #####: 2721:    if (item->valuestring)
branch  0 never executed
branch  1 never executed
        -: 2722:    {
    #####: 2723:        newitem->valuestring = (char*)cJSON_strdup((unsigned char*)item->valuestring, &global_hooks);
call    0 never executed
    #####: 2724:        if (!newitem->valuestring)
branch  0 never executed
branch  1 never executed
        -: 2725:        {
    #####: 2726:            goto fail;
        -: 2727:        }
        -: 2728:    }
    #####: 2729:    if (item->string)
branch  0 never executed
branch  1 never executed
        -: 2730:    {
    #####: 2731:        newitem->string = (item->type&cJSON_StringIsConst) ? item->string : (char*)cJSON_strdup((unsigned char*)item->string, &global_hooks);
branch  0 never executed
branch  1 never executed
call    2 never executed
    #####: 2732:        if (!newitem->string)
branch  0 never executed
branch  1 never executed
        -: 2733:        {
    #####: 2734:            goto fail;
        -: 2735:        }
        -: 2736:    }
        -: 2737:    /* If non-recursive, then we're done! */
    #####: 2738:    if (!recurse)
branch  0 never executed
branch  1 never executed
        -: 2739:    {
    #####: 2740:        return newitem;
        -: 2741:    }
        -: 2742:    /* Walk the ->next chain for the child. */
    #####: 2743:    child = item->child;
    #####: 2744:    while (child != NULL)
branch  0 never executed
branch  1 never executed
        -: 2745:    {
    #####: 2746:        newchild = cJSON_Duplicate(child, true); /* Duplicate (with recurse) each item in the ->next chain */
call    0 never executed
    #####: 2747:        if (!newchild)
branch  0 never executed
branch  1 never executed
        -: 2748:        {
    #####: 2749:            goto fail;
        -: 2750:        }
    #####: 2751:        if (next != NULL)
branch  0 never executed
branch  1 never executed
        -: 2752:        {
        -: 2753:            /* If newitem->child already set, then crosswire ->prev and ->next and move on */
    #####: 2754:            next->next = newchild;
    #####: 2755:            newchild->prev = next;
    #####: 2756:            next = newchild;
        -: 2757:        }
        -: 2758:        else
        -: 2759:        {
        -: 2760:            /* Set newitem->child and move to it */
    #####: 2761:            newitem->child = newchild;
    #####: 2762:            next = newchild;
        -: 2763:        }
    #####: 2764:        child = child->next;
        -: 2765:    }
    #####: 2766:    if (newitem && newitem->child)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2767:    {
    #####: 2768:        newitem->child->prev = newchild;
        -: 2769:    }
        -: 2770:
    #####: 2771:    return newitem;
        -: 2772:
    #####: 2773:fail:
    #####: 2774:    if (newitem != NULL)
branch  0 never executed
branch  1 never executed
        -: 2775:    {
    #####: 2776:        cJSON_Delete(newitem);
call    0 never executed
        -: 2777:    }
        -: 2778:
    #####: 2779:    return NULL;
        -: 2780:}
        -: 2781:
function skip_oneline_comment called 0 returned 0% blocks executed 0%
    #####: 2782:static void skip_oneline_comment(char **input)
        -: 2783:{
    #####: 2784:    *input += static_strlen("//");
        -: 2785:
    #####: 2786:    for (; (*input)[0] != '\0'; ++(*input))
branch  0 never executed
branch  1 never executed
        -: 2787:    {
    #####: 2788:        if ((*input)[0] == '\n') {
branch  0 never executed
branch  1 never executed
    #####: 2789:            *input += static_strlen("\n");
    #####: 2790:            return;
        -: 2791:        }
        -: 2792:    }
        -: 2793:}
        -: 2794:
function skip_multiline_comment called 0 returned 0% blocks executed 0%
    #####: 2795:static void skip_multiline_comment(char **input)
        -: 2796:{
    #####: 2797:    *input += static_strlen("/*");
        -: 2798:
    #####: 2799:    for (; (*input)[0] != '\0'; ++(*input))
branch  0 never executed
branch  1 never executed
        -: 2800:    {
    #####: 2801:        if (((*input)[0] == '*') && ((*input)[1] == '/'))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2802:        {
    #####: 2803:            *input += static_strlen("*/");
    #####: 2804:            return;
        -: 2805:        }
        -: 2806:    }
        -: 2807:}
        -: 2808:
function minify_string called 0 returned 0% blocks executed 0%
    #####: 2809:static void minify_string(char **input, char **output) {
    #####: 2810:    (*output)[0] = (*input)[0];
    #####: 2811:    *input += static_strlen("\"");
    #####: 2812:    *output += static_strlen("\"");
        -: 2813:
        -: 2814:
    #####: 2815:    for (; (*input)[0] != '\0'; (void)++(*input), ++(*output)) {
branch  0 never executed
branch  1 never executed
    #####: 2816:        (*output)[0] = (*input)[0];
        -: 2817:
    #####: 2818:        if ((*input)[0] == '\"') {
branch  0 never executed
branch  1 never executed
    #####: 2819:            (*output)[0] = '\"';
    #####: 2820:            *input += static_strlen("\"");
    #####: 2821:            *output += static_strlen("\"");
    #####: 2822:            return;
    #####: 2823:        } else if (((*input)[0] == '\\') && ((*input)[1] == '\"')) {
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2824:            (*output)[1] = (*input)[1];
    #####: 2825:            *input += static_strlen("\"");
    #####: 2826:            *output += static_strlen("\"");
        -: 2827:        }
        -: 2828:    }
        -: 2829:}
        -: 2830:
function cJSON_Minify called 0 returned 0% blocks executed 0%
    #####: 2831:CJSON_PUBLIC(void) cJSON_Minify(char *json)
        -: 2832:{
    #####: 2833:    char *into = json;
        -: 2834:
    #####: 2835:    if (json == NULL)
branch  0 never executed
branch  1 never executed
        -: 2836:    {
    #####: 2837:        return;
        -: 2838:    }
        -: 2839:
    #####: 2840:    while (json[0] != '\0')
branch  0 never executed
branch  1 never executed
        -: 2841:    {
    #####: 2842:        switch (json[0])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 2843:        {
    #####: 2844:            case ' ':
        -: 2845:            case '\t':
        -: 2846:            case '\r':
        -: 2847:            case '\n':
    #####: 2848:                json++;
    #####: 2849:                break;
        -: 2850:
    #####: 2851:            case '/':
    #####: 2852:                if (json[1] == '/')
branch  0 never executed
branch  1 never executed
        -: 2853:                {
    #####: 2854:                    skip_oneline_comment(&json);
call    0 never executed
        -: 2855:                }
    #####: 2856:                else if (json[1] == '*')
branch  0 never executed
branch  1 never executed
        -: 2857:                {
    #####: 2858:                    skip_multiline_comment(&json);
call    0 never executed
        -: 2859:                } else {
    #####: 2860:                    json++;
        -: 2861:                }
    #####: 2862:                break;
        -: 2863:
    #####: 2864:            case '\"':
    #####: 2865:                minify_string(&json, (char**)&into);
call    0 never executed
    #####: 2866:                break;
        -: 2867:
    #####: 2868:            default:
    #####: 2869:                into[0] = json[0];
    #####: 2870:                json++;
    #####: 2871:                into++;
        -: 2872:        }
        -: 2873:    }
        -: 2874:
        -: 2875:    /* and null-terminate. */
    #####: 2876:    *into = '\0';
        -: 2877:}
        -: 2878:
function cJSON_IsInvalid called 0 returned 0% blocks executed 0%
    #####: 2879:CJSON_PUBLIC(cJSON_bool) cJSON_IsInvalid(const cJSON * const item)
        -: 2880:{
    #####: 2881:    if (item == NULL)
branch  0 never executed
branch  1 never executed
        -: 2882:    {
    #####: 2883:        return false;
        -: 2884:    }
        -: 2885:
    #####: 2886:    return (item->type & 0xFF) == cJSON_Invalid;
        -: 2887:}
        -: 2888:
function cJSON_IsFalse called 0 returned 0% blocks executed 0%
    #####: 2889:CJSON_PUBLIC(cJSON_bool) cJSON_IsFalse(const cJSON * const item)
        -: 2890:{
    #####: 2891:    if (item == NULL)
branch  0 never executed
branch  1 never executed
        -: 2892:    {
    #####: 2893:        return false;
        -: 2894:    }
        -: 2895:
    #####: 2896:    return (item->type & 0xFF) == cJSON_False;
        -: 2897:}
        -: 2898:
function cJSON_IsTrue called 0 returned 0% blocks executed 0%
    #####: 2899:CJSON_PUBLIC(cJSON_bool) cJSON_IsTrue(const cJSON * const item)
        -: 2900:{
    #####: 2901:    if (item == NULL)
branch  0 never executed
branch  1 never executed
        -: 2902:    {
    #####: 2903:        return false;
        -: 2904:    }
        -: 2905:
    #####: 2906:    return (item->type & 0xff) == cJSON_True;
        -: 2907:}
        -: 2908:
        -: 2909:
function cJSON_IsBool called 0 returned 0% blocks executed 0%
    #####: 2910:CJSON_PUBLIC(cJSON_bool) cJSON_IsBool(const cJSON * const item)
        -: 2911:{
    #####: 2912:    if (item == NULL)
branch  0 never executed
branch  1 never executed
        -: 2913:    {
    #####: 2914:        return false;
        -: 2915:    }
        -: 2916:
    #####: 2917:    return (item->type & (cJSON_True | cJSON_False)) != 0;
        -: 2918:}
function cJSON_IsNull called 0 returned 0% blocks executed 0%
    #####: 2919:CJSON_PUBLIC(cJSON_bool) cJSON_IsNull(const cJSON * const item)
        -: 2920:{
    #####: 2921:    if (item == NULL)
branch  0 never executed
branch  1 never executed
        -: 2922:    {
    #####: 2923:        return false;
        -: 2924:    }
        -: 2925:
    #####: 2926:    return (item->type & 0xFF) == cJSON_NULL;
        -: 2927:}
        -: 2928:
function cJSON_IsNumber called 0 returned 0% blocks executed 0%
    #####: 2929:CJSON_PUBLIC(cJSON_bool) cJSON_IsNumber(const cJSON * const item)
        -: 2930:{
    #####: 2931:    if (item == NULL)
branch  0 never executed
branch  1 never executed
        -: 2932:    {
    #####: 2933:        return false;
        -: 2934:    }
        -: 2935:
    #####: 2936:    return (item->type & 0xFF) == cJSON_Number;
        -: 2937:}
        -: 2938:
function cJSON_IsString called 0 returned 0% blocks executed 0%
    #####: 2939:CJSON_PUBLIC(cJSON_bool) cJSON_IsString(const cJSON * const item)
        -: 2940:{
    #####: 2941:    if (item == NULL)
branch  0 never executed
branch  1 never executed
        -: 2942:    {
    #####: 2943:	    printf("dpqkwl\n");
call    0 never executed
    #####: 2944:        return false;
        -: 2945:    }
        -: 2946:
    #####: 2947:    return (item->type & 0xFF) == cJSON_String;
        -: 2948:}
        -: 2949:
function cJSON_IsArray called 0 returned 0% blocks executed 0%
    #####: 2950:CJSON_PUBLIC(cJSON_bool) cJSON_IsArray(const cJSON * const item)
        -: 2951:{
    #####: 2952:    if (item == NULL)
branch  0 never executed
branch  1 never executed
        -: 2953:    {
    #####: 2954:        return false;
        -: 2955:    }
        -: 2956:
    #####: 2957:    return (item->type & 0xFF) == cJSON_Array;
        -: 2958:}
        -: 2959:
function cJSON_IsObject called 0 returned 0% blocks executed 0%
    #####: 2960:CJSON_PUBLIC(cJSON_bool) cJSON_IsObject(const cJSON * const item)
        -: 2961:{
    #####: 2962:    if (item == NULL)
branch  0 never executed
branch  1 never executed
        -: 2963:    {
    #####: 2964:        return false;
        -: 2965:    }
        -: 2966:
    #####: 2967:    return (item->type & 0xFF) == cJSON_Object;
        -: 2968:}
        -: 2969:
function cJSON_IsRaw called 0 returned 0% blocks executed 0%
    #####: 2970:CJSON_PUBLIC(cJSON_bool) cJSON_IsRaw(const cJSON * const item)
        -: 2971:{
    #####: 2972:    if (item == NULL)
branch  0 never executed
branch  1 never executed
        -: 2973:    {
    #####: 2974:        return false;
        -: 2975:    }
        -: 2976:
    #####: 2977:    return (item->type & 0xFF) == cJSON_Raw;
        -: 2978:}
        -: 2979:
function cJSON_Compare called 0 returned 0% blocks executed 0%
    #####: 2980:CJSON_PUBLIC(cJSON_bool) cJSON_Compare(const cJSON * const a, const cJSON * const b, const cJSON_bool case_sensitive)
        -: 2981:{
    #####: 2982:    if ((a == NULL) || (b == NULL) || ((a->type & 0xFF) != (b->type & 0xFF)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 2983:    {
    #####: 2984:        return false;
        -: 2985:    }
        -: 2986:
        -: 2987:    /* check if type is valid */
    #####: 2988:    switch (a->type & 0xFF)
branch  0 never executed
branch  1 never executed
        -: 2989:    {
    #####: 2990:        case cJSON_False:
        -: 2991:        case cJSON_True:
        -: 2992:        case cJSON_NULL:
        -: 2993:        case cJSON_Number:
        -: 2994:        case cJSON_String:
        -: 2995:        case cJSON_Raw:
        -: 2996:        case cJSON_Array:
        -: 2997:        case cJSON_Object:
    #####: 2998:            break;
        -: 2999:
    #####: 3000:        default:
    #####: 3001:            return false;
        -: 3002:    }
        -: 3003:
        -: 3004:    /* identical objects are equal */
    #####: 3005:    if (a == b)
branch  0 never executed
branch  1 never executed
        -: 3006:    {
    #####: 3007:        return true;
        -: 3008:    }
        -: 3009:
    #####: 3010:    switch (a->type & 0xFF)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 3011:    {
        -: 3012:        /* in these cases and equal type is enough */
    #####: 3013:        case cJSON_False:
        -: 3014:        case cJSON_True:
        -: 3015:        case cJSON_NULL:
    #####: 3016:            return true;
        -: 3017:
    #####: 3018:        case cJSON_Number:
    #####: 3019:            if (compare_double(a->valuedouble, b->valuedouble))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 3020:            {
    #####: 3021:                return true;
        -: 3022:            }
    #####: 3023:            return false;
        -: 3024:
    #####: 3025:        case cJSON_String:
        -: 3026:        case cJSON_Raw:
    #####: 3027:            if ((a->valuestring == NULL) || (b->valuestring == NULL))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3028:            {
    #####: 3029:                return false;
        -: 3030:            }
    #####: 3031:            if (strcmp(a->valuestring, b->valuestring) == 0)
branch  0 never executed
branch  1 never executed
        -: 3032:            {
    #####: 3033:                return true;
        -: 3034:            }
        -: 3035:
    #####: 3036:            return false;
        -: 3037:
    #####: 3038:        case cJSON_Array:
        -: 3039:        {
    #####: 3040:            cJSON *a_element = a->child;
    #####: 3041:            cJSON *b_element = b->child;
        -: 3042:
    #####: 3043:            for (; (a_element != NULL) && (b_element != NULL);)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3044:            {
    #####: 3045:                if (!cJSON_Compare(a_element, b_element, case_sensitive))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 3046:                {
    #####: 3047:                    return false;
        -: 3048:                }
        -: 3049:
    #####: 3050:                a_element = a_element->next;
    #####: 3051:                b_element = b_element->next;
        -: 3052:            }
        -: 3053:
        -: 3054:            /* one of the arrays is longer than the other */
    #####: 3055:            if (a_element != b_element) {
branch  0 never executed
branch  1 never executed
    #####: 3056:                return false;
        -: 3057:            }
        -: 3058:
    #####: 3059:            return true;
        -: 3060:        }
        -: 3061:
    #####: 3062:        case cJSON_Object:
        -: 3063:        {
    #####: 3064:            cJSON *a_element = NULL;
    #####: 3065:            cJSON *b_element = NULL;
    #####: 3066:            cJSON_ArrayForEach(a_element, a)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3067:            {
        -: 3068:                /* TODO This has O(n^2) runtime, which is horrible! */
    #####: 3069:                b_element = get_object_item(b, a_element->string, case_sensitive);
call    0 never executed
    #####: 3070:                if (b_element == NULL)
branch  0 never executed
branch  1 never executed
        -: 3071:                {
    #####: 3072:                    return false;
        -: 3073:                }
        -: 3074:
    #####: 3075:                if (!cJSON_Compare(a_element, b_element, case_sensitive))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 3076:                {
    #####: 3077:                    return false;
        -: 3078:                }
        -: 3079:            }
        -: 3080:
        -: 3081:            /* doing this twice, once on a and b to prevent true comparison if a subset of b
        -: 3082:             * TODO: Do this the proper way, this is just a fix for now */
    #####: 3083:            cJSON_ArrayForEach(b_element, b)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 3084:            {
    #####: 3085:                a_element = get_object_item(a, b_element->string, case_sensitive);
call    0 never executed
    #####: 3086:                if (a_element == NULL)
branch  0 never executed
branch  1 never executed
        -: 3087:                {
    #####: 3088:                    return false;
        -: 3089:                }
        -: 3090:
    #####: 3091:                if (!cJSON_Compare(b_element, a_element, case_sensitive))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 3092:                {
    #####: 3093:                    return false;
        -: 3094:                }
        -: 3095:            }
        -: 3096:
    #####: 3097:            return true;
        -: 3098:        }
        -: 3099:
    #####: 3100:        default:
    #####: 3101:            return false;
        -: 3102:    }
        -: 3103:}
        -: 3104:
function cJSON_malloc called 0 returned 0% blocks executed 0%
    #####: 3105:CJSON_PUBLIC(void *) cJSON_malloc(size_t size)
        -: 3106:{
    #####: 3107:    return global_hooks.allocate(size);
call    0 never executed
        -: 3108:}
        -: 3109:
function cJSON_free called 0 returned 0% blocks executed 0%
    #####: 3110:CJSON_PUBLIC(void) cJSON_free(void *object)
        -: 3111:{
    #####: 3112:    global_hooks.deallocate(object);
call    0 never executed
    #####: 3113:}
